[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Prise en main de R et RStudio",
    "section": "",
    "text": "Introduction\nR est un langage de programmation et un environnement statistique open-source, largement utilisé pour l’analyse de données, les statistiques et la science des données. Créé dans les années 1990 par Ross Ihaka et Robert Gentleman, il est particulièrement apprécié pour sa puissance dans le traitement des données, la modélisation statistique et la visualisation graphique. Grâce à une vaste communauté de développeurs, R bénéficie d’un large écosystème de packages (via CRAN) qui étendent ses fonctionnalités dans divers domaines, comme l’apprentissage automatique, la bioinformatique et l’économétrie.\nRStudio est un environnement de développement intégré (IDE) conçu pour faciliter l’utilisation de R. Il offre une interface conviviale avec un éditeur de code avancé, une console interactive, des outils de visualisation et un gestionnaire de projets. Disponible en version gratuite et professionnelle, RStudio améliore l’expérience utilisateur grâce à des fonctionnalités telles que l’auto-complétion du code, l’intégration avec Git, la gestion des environnements et la possibilité de générer des rapports dynamiques avec R Markdown et Quarto.\nSur RStudio il est possible d’utiliser R Markdown et Quarto:\n\nR Markdown est un format de document qui permet d’intégrer du code R dans un fichier texte et de générer des rapports dynamiques sous divers formats (HTML, PDF, Word, etc.). Il est très utilisé pour la documentation, les rapports d’analyse et les présentations interactives.\nQuarto est une évolution de R Markdown, plus flexible et multi-langage, permettant d’intégrer du code non seulement en R, mais aussi en Python, Julia et d’autres langages. Il est conçu pour produire des documents scientifiques, des articles, des tableaux de bord et des sites web interactifs avec un meilleur support pour la reproductibilité des analyses.\n\n\nEnsemble, R, RStudio, R Markdown et Quarto forment un écosystème puissant pour l’analyse de données, la visualisation et la communication scientifique, largement utilisé dans les milieux académiques et professionnels.\nCe cours fournit une introduction aux bases de R, en mettant l’accent sur les applications statistiques.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "install_RStudio.html",
    "href": "install_RStudio.html",
    "title": "Installation de RStudio",
    "section": "",
    "text": "Rstudio est un IDE.\n\nEn programmation informatique, un IDE (environnement de développement) est un ensemble d’outils qui permet d’augmenter la productivité des programmeurs qui développent des logiciels. Source : Wikipédia\n\nDans cette partie vous allez apprendre à installer RStudio, l’environnement dans lequel vous allez coder en R.\nRStudio : L’interface utilisateur graphique que vous allez utiliser pour travailler avec R. Téléchargez-le depuis RStudio. Choisissez bien l’installateur associé à votre système d’exploitation et suivez les consignes.",
    "crumbs": [
      "R et RStudio",
      "Installation de RStudio"
    ]
  },
  {
    "objectID": "install_R.html",
    "href": "install_R.html",
    "title": "Installation de R",
    "section": "",
    "text": "R : Rendez-vous sur le site officiel CRAN. pour télécharger et installer R.\n\nPour toutes les personnes utilisant Linux, choisissez la bonne page entre parenthèses et suivez les consignes pour télécharger et installer R.\nPour les personnes utilisant MacOS, téléchargez l’installateur en fonction de votre système et lancez-le.\nPour les personnes utilisant Windows, téléchargez l’installateur en cliquant sur install R for the first time puis lancez-le. Vous devez aussi installer Rtools via le lien sur le CRAN ou en utilisant les lignes de code suivantes dans R :\n\ninstall.packages(\"utils\")\ninstall.packages(\"installr\")\ninstallr::install.Rtools()",
    "crumbs": [
      "R et RStudio",
      "Installation de R"
    ]
  },
  {
    "objectID": "exos.html",
    "href": "exos.html",
    "title": "Exercices",
    "section": "",
    "text": "Ces exercices ont été rédigé et construit par Justine Guégan (Paris Brain Institute).",
    "crumbs": [
      "Exercices"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html",
    "href": "exos/manip_objets_R.html",
    "title": "Manipulation des objets sur R",
    "section": "",
    "text": "Exercice 1\nSoit a=c(“lannister”, “targaryen”, “baratheon”, “starck”, “greyjoy”)\n\nQuelle est la longueur du vecteur ? indice : length\nEssayez de faire a[1:3]. Qu’obtenez-vous ?\nCréez un nouveau vecteur b ne contenant que lannister et starck.\nEssayez de faire a[-1]. Qu’obtenez-vous ?\nTriez par ordre alphabetique. indice : sort ?\n\na=c(\"lannister\", \"targaryen\", \"baratheon\", \"starck\", \"greyjoy\")\nlength(a)\na[1:3]\nb = a[c(1,4)]\na [-1]\nsort(a)\n\n\nExercice 2\n\nCréez un vecteur a contenant tous les entiers de 1 à 100. Indice: “:”.\nAjoutez les valeurs 200, 201, 202 au vecteur a. Indice : c().\nCréez un vecteur b contenant tous les entiers pairs de 2 à 100. Indice: seq.\n\n\\(\\mathrm{a}=\\mathrm{c}(1: 100)\\) c (a, 200, 201, 202) \\(b=\\operatorname{seq}(\\) from \\(=2\\), to \\(=100\\), by \\(=2\\) )\n\n\nExercice 3\n\nCréer le vecteur vec1 contenant tous les multiples de 2 compris entre 1 et 50 .\nCréer le vecteur vec 2 contenant 3 fois chacun des 10 chiffres (soit \\(0,0,0 ; 1,1,1 ; 2,2,2 ; 3,3,3\\); etc.). Indice: \\(r e p()\\)\nCréer le vecteur vec3 contenant une fois le chiffre 1, deux fois le chiffre 2 , trois fois le chiffre \\(3 \\ldots\\) et 20 fois le chiffre 20. Quelle est la longueur de cette suite? Indice: length()\n\nPensez à bien regarder l’aide des fonctions. Par exemple, pour la fonction rep regardez bien la différence entre les paramètres each et times ; vous pouvez copier-coller les lignes d’exemple pour bien comprendre chaque paramètre.\n#1\nvec1 = seq(from=2, to=50, by=2 )\n#2\nvec2 = rep(c(0:9), each=3)\n#3\nvec3 = rep(1:20, times = c(1:20))\nlength(vec3)\n\n\nExercice 4\nLa commande paste permet de concataner du texte. Essayez paste(“chr”, 1, sep=““). Créez, en une seule ligne de commande, le vecteur vec4 contenant les noms suivants : chr1, chr2,… , chr22, chrX, chrY. Indice : paste()\npaste(\"chr\", 1, sep=\"\")\nvec4 = paste(\"chr\", c(1:22,\"X\",\"Y\"), sep=\"\")\n\n\nExercice 5 : Facteurs\n\nDéfinissez un facteur fac = factor (c(“a”, “b”, “b”, “b”, “a”, “b”, “a”, “a”)).\nCalculez le nombre de “a” et de “b” dans fac en utilisant les fonctions which et length et des opérateurs binaires (==).\nQue permet de faire la fonction table? Appliquez la à fac. Retenez bien la fonction table très très utile!\n\nfac = factor(c(\"a\",\"b\",\"b\",\"b\",\"a\",\"b\",\"a\",\"a\"))\nlength(which(fac == \"a\"))\nlength(which(fac == \"b\"))\ntable(fac)\n\n\nExercice 6 : Matrices\n\nExécutez la commande \\(a=\\operatorname{rep}(c(0,1), 50)\\). Qu’a-t-on fait?\nUtilisez a pour construire une matrice A à 10 lignes et 10 colonnes. indice : matrix ().\nAffichez les dimensions de cette matrice. Indices : dim, ncol, nrow\nUtilisez la fonction \\(t\\) sur cette matrice pour créer une matrice B. Que s’est-il passé ?\n\n5 . Les commandes \\(\\mathrm{A}[1: 5\\), ] et \\(\\mathrm{B}[, 1: 5]\\) permettent de récuperer respectivement les 5 premières lignes de A et les 5 premières colonnes de B. Inspirez-vous de ces commandes pour récupérez dans A les lignes ne contenant que des 1 et dans \\(B\\) les colonnes ne contenant que des 0 .\n#1\na = rep(c(0,1), 50)\n#2\nA = matrix(a, ncol = 10, nrow = 10)\n#3\ndim(A)\nncol(A)\nnrow(A)\n#4\nB = t(A)\n#5\nline1 = A[seq(2,10,2),]\ncol0 = B[,seq(1,10,2)]\n\n\nExercice 7 : Liste et tableaux de données (data.frame)\n\nCréez une liste x contenant:\n\n\nune variable aléatoire gaussienne de taille 10 appelée a\nun vecteur contenant uniquement des 1 de taille 10 également, appelé b. On peut accéder aux deux éléments de cette liste avec les commandes \\(\\mathrm{x}[\\mathrm{i}]\\) ] ou x$nom_de_la_variable. Indices : list, rnorm.\n\n\nCréez un objet y qui est la transformation de cette liste en data.frame. On peut maintenant parcourir les éléments de chaque objet comme pour une matrice avec la commande y \\([i, j]!\\) indice \\(=\\) as. data.frame\nCréez deux objets z1 et z2 contenant respectivement les 3 premières et les 3 dernières lignes de y. Quelle est la classe de ces deux objets ?\nRajoutez à la liste x un vecteur chiffre contenant les entiers de 1 à 26 .\nEssayez de transformer de nouveau \\(x\\) en data.frame. Que se passe-t-il?\n\n#1\nx = list(\n    a = rnorm(10),\n    b = rep(1, 10)\n)\nx[[\"a\"]]\nx$a\n#2\ny = as.data.frame(x)\n#3\nz1 = y[c(1:3) ,]\nz2 = y[c(8:10),]\nclass(z1)\nclass(z2)\n#4\nx$chiffre = 1:26\n#5\nas.data.frame(x)\n\n\nExercice 8 : Student’s Sleep Data\n\nExecutez la commande data(sleep). Nous venons de charger en mémoire l’un des nombreux jeux de données distribués avec R ! Profitez de l’aide sur ce jeu de données pour en apprendre un peu plus (?sleep)! Tous les jeux de données disponibles avec l’installation de base de R sont accessibles en tapant data().\nQuel est le type de l’objet sleep ?\nQuelle fonction vous permet d’obtenir rapidement le nombre d’individus par groupe? Executez la.\nCombien y-a-t-il de valeurs négatives dans le groupe 1 ? Indice : which()\nSoit s un vecteur représentant le sexe des individus: s = rep(c(“f”,“m”,“m”,“f”,“m”,“f”,“m”,“m”,“f”,“m”),2). Combinez l’objet sleep et le vecteur s dans une nouvelle matrice sleep2. Indice : cbind()\nQuelles sont les noms des colonnes de la matrice sleep2? Renommez la dernière colonne en ‘sex’. Indice: colnames ()\nCombien \\(y\\)-a-t-il de femmes et d’hommes dans chacun des groupes ?\n\n#1\ndata(sleep)\n#2\ntypeof(sleep); class(sleep)\n#3\ntable(sleep$group)\n#4\nlength(which(sleep$extra &lt; 0))\n#5\ns = rep(c(\"f\",\"m\",\"m\",\"f\",\"m\",\"f\",\"m\",\"m\",\"f\",\"m\"),2)\nsleep2 = cbind(sleep, s)\n#6\ncolnames(sleep2)\ncolnames(sleep2)[4] = \"sex\"\n#7\ntable(sleep2$s, sleep2$group)",
    "crumbs": [
      "Exercices",
      "Manipulation des objets sur R"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-1",
    "href": "exos/manip_objets_R.html#exercice-1",
    "title": "18  Manipulation des objets sur R",
    "section": "",
    "text": "Quelle est la longueur du vecteur ? indice : length\nEssayez de faire a[1:3]. Qu’obtenez-vous ?\nCréez un nouveau vecteur b ne contenant que lannister et starck.\nEssayez de faire a[-1]. Qu’obtenez-vous ?\nTriez par ordre alphabetique. indice : sort ?\n\na=c(\"lannister\", \"targaryen\", \"baratheon\", \"starck\", \"greyjoy\")\nlength(a)\na[1:3]\nb = a[c(1,4)]\na [-1]\nsort(a)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-2",
    "href": "exos/manip_objets_R.html#exercice-2",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 2",
    "text": "Exercice 2\n\nCréez un vecteur a contenant tous les entiers de 1 à 100. Indice: “:”.\nAjoutez les valeurs 200, 201, 202 au vecteur a. Indice : c().\nCréez un vecteur b contenant tous les entiers pairs de 2 à 100. Indice: seq.\n\n\\(\\mathrm{a}=\\mathrm{c}(1: 100)\\) c (a, 200, 201, 202) \\(b=\\operatorname{seq}(\\) from \\(=2\\), to \\(=100\\), by \\(=2\\) )",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-3",
    "href": "exos/manip_objets_R.html#exercice-3",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 3",
    "text": "Exercice 3\n\nCréer le vecteur vec1 contenant tous les multiples de 2 compris entre 1 et 50 .\nCréer le vecteur vec 2 contenant 3 fois chacun des 10 chiffres (soit \\(0,0,0 ; 1,1,1 ; 2,2,2 ; 3,3,3\\); etc.). Indice: \\(r e p()\\)\nCréer le vecteur vec3 contenant une fois le chiffre 1, deux fois le chiffre 2 , trois fois le chiffre \\(3 \\ldots\\) et 20 fois le chiffre 20. Quelle est la longueur de cette suite? Indice: length()\n\nPensez à bien regarder l’aide des fonctions. Par exemple, pour la fonction rep regardez bien la différence entre les paramètres each et times ; vous pouvez copier-coller les lignes d’exemple pour bien comprendre chaque paramètre.\n#1\nvec1 = seq(from=2, to=50, by=2 )\n#2\nvec2 = rep(c(0:9), each=3)\n#3\nvec3 = rep(1:20, times = c(1:20))\nlength(vec3)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-4",
    "href": "exos/manip_objets_R.html#exercice-4",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 4",
    "text": "Exercice 4\nLa commande paste permet de concataner du texte. Essayez paste(“chr”, 1, sep=““). Créez, en une seule ligne de commande, le vecteur vec4 contenant les noms suivants : chr1, chr2,… , chr22, chrX, chrY. Indice : paste()\npaste(\"chr\", 1, sep=\"\")\nvec4 = paste(\"chr\", c(1:22,\"X\",\"Y\"), sep=\"\")",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-5-facteurs",
    "href": "exos/manip_objets_R.html#exercice-5-facteurs",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 5 : Facteurs",
    "text": "Exercice 5 : Facteurs\n\nDéfinissez un facteur fac = factor (c(“a”, “b”, “b”, “b”, “a”, “b”, “a”, “a”)).\nCalculez le nombre de “a” et de “b” dans fac en utilisant les fonctions which et length et des opérateurs binaires (==).\nQue permet de faire la fonction table? Appliquez la à fac. Retenez bien la fonction table très très utile!\n\nfac = factor(c(\"a\",\"b\",\"b\",\"b\",\"a\",\"b\",\"a\",\"a\"))\nlength(which(fac == \"a\"))\nlength(which(fac == \"b\"))\ntable(fac)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-6-matrices",
    "href": "exos/manip_objets_R.html#exercice-6-matrices",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 6 : Matrices",
    "text": "Exercice 6 : Matrices\n\nExécutez la commande \\(a=\\operatorname{rep}(c(0,1), 50)\\). Qu’a-t-on fait?\nUtilisez a pour construire une matrice A à 10 lignes et 10 colonnes. indice : matrix ().\nAffichez les dimensions de cette matrice. Indices : dim, ncol, nrow\nUtilisez la fonction \\(t\\) sur cette matrice pour créer une matrice B. Que s’est-il passé ?\n\n5 . Les commandes \\(\\mathrm{A}[1: 5\\), ] et \\(\\mathrm{B}[, 1: 5]\\) permettent de récuperer respectivement les 5 premières lignes de A et les 5 premières colonnes de B. Inspirez-vous de ces commandes pour récupérez dans A les lignes ne contenant que des 1 et dans \\(B\\) les colonnes ne contenant que des 0 .\n#1\na = rep(c(0,1), 50)\n#2\nA = matrix(a, ncol = 10, nrow = 10)\n#3\ndim(A)\nncol(A)\nnrow(A)\n#4\nB = t(A)\n#5\nline1 = A[seq(2,10,2),]\ncol0 = B[,seq(1,10,2)]",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-7-liste-et-tableaux-de-données-data.frame",
    "href": "exos/manip_objets_R.html#exercice-7-liste-et-tableaux-de-données-data.frame",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 7 : Liste et tableaux de données (data.frame)",
    "text": "Exercice 7 : Liste et tableaux de données (data.frame)\n\nCréez une liste x contenant:\n\n\nune variable aléatoire gaussienne de taille 10 appelée a\nun vecteur contenant uniquement des 1 de taille 10 également, appelé b. On peut accéder aux deux éléments de cette liste avec les commandes \\(\\mathrm{x}[\\mathrm{i}]\\) ] ou x$nom_de_la_variable. Indices : list, rnorm.\n\n\nCréez un objet y qui est la transformation de cette liste en data.frame. On peut maintenant parcourir les éléments de chaque objet comme pour une matrice avec la commande y \\([i, j]!\\) indice \\(=\\) as. data.frame\nCréez deux objets z1 et z2 contenant respectivement les 3 premières et les 3 dernières lignes de y. Quelle est la classe de ces deux objets ?\nRajoutez à la liste x un vecteur chiffre contenant les entiers de 1 à 26 .\nEssayez de transformer de nouveau \\(x\\) en data.frame. Que se passe-t-il?\n\n#1\nx = list(\n    a = rnorm(10),\n    b = rep(1, 10)\n)\nx[[\"a\"]]\nx$a\n#2\ny = as.data.frame(x)\n#3\nz1 = y[c(1:3) ,]\nz2 = y[c(8:10),]\nclass(z1)\nclass(z2)\n#4\nx$chiffre = 1:26\n#5\nas.data.frame(x)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/manip_objets_R.html#exercice-8-students-sleep-data",
    "href": "exos/manip_objets_R.html#exercice-8-students-sleep-data",
    "title": "18  Manipulation des objets sur R",
    "section": "Exercice 8 : Student’s Sleep Data",
    "text": "Exercice 8 : Student’s Sleep Data\n\nExecutez la commande data(sleep). Nous venons de charger en mémoire l’un des nombreux jeux de données distribués avec R ! Profitez de l’aide sur ce jeu de données pour en apprendre un peu plus (?sleep)! Tous les jeux de données disponibles avec l’installation de base de R sont accessibles en tapant data().\nQuel est le type de l’objet sleep ?\nQuelle fonction vous permet d’obtenir rapidement le nombre d’individus par groupe? Executez la.\nCombien y-a-t-il de valeurs négatives dans le groupe 1 ? Indice : which()\nSoit s un vecteur représentant le sexe des individus: s = rep(c(“f”,“m”,“m”,“f”,“m”,“f”,“m”,“m”,“f”,“m”),2). Combinez l’objet sleep et le vecteur s dans une nouvelle matrice sleep2. Indice : cbind()\nQuelles sont les noms des colonnes de la matrice sleep2? Renommez la dernière colonne en ‘sex’. Indice: colnames ()\nCombien \\(y\\)-a-t-il de femmes et d’hommes dans chacun des groupes ?\n\n#1\ndata(sleep)\n#2\ntypeof(sleep); class(sleep)\n#3\ntable(sleep$group)\n#4\nlength(which(sleep$extra &lt; 0))\n#5\ns = rep(c(\"f\",\"m\",\"m\",\"f\",\"m\",\"f\",\"m\",\"m\",\"f\",\"m\"),2)\nsleep2 = cbind(sleep, s)\n#6\ncolnames(sleep2)\ncolnames(sleep2)[4] = \"sex\"\n#7\ntable(sleep2$s, sleep2$group)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Manipulation des objets sur R</span>"
    ]
  },
  {
    "objectID": "exos/read_save_dataset.html",
    "href": "exos/read_save_dataset.html",
    "title": "Lire et sauvegarder des données",
    "section": "",
    "text": "Exercice 9 : Lire les données d’un fichier : fonction read.table\nIl est possible de lire les données stockées dans des fichiers sous format txt grÃcce, entre autres, aux fonctions suivantes: read.table(), read.csv(), read.csv2() et scan(). Par ailleurs, la fonction read.xls() (resp. write.xls()) du package gdata fournit les outils pour lire (resp. écrire) des fichiers au format Excel. Il existe aussi la fonction read.xlsx (resp. write. xlsx) du package xlsx. (Récupérez les fichiers demandés sur le site \\(\\operatorname{xxxxxxx}\\) ). Vous pouvez ouvrir au préalable ces différents fichiers dans un éditeur de texte afin d’identifier le séparateur de colonnes, le symbole de décimale, comment sont définies les valeurs manquantes etc…\n\nImportez dans une variable nommée A le jeu de données nommé auto2004_original.txt. \\({ }^{* *}\\) Indice : le séparateur de colonne ‘tabulation’ correspond à “en informatique*\nImportez dans une variable nommée B le jeu de données auto2004_sans_nom.txt.\nImportez dans une variable nommée \\(C\\) le jeu de données auto2004_virgule.txt.\nImportez dans une variable nommée D le jeu de données auto2004_don_manquante.txt. Combien de valeurs manquantes sont contenues dans le fichier?\nImportez dans une variable nommée E le jeu de données auto2004_don_manquante (99999).txt.\nQuel est le mode des objets créés par la fonction read.table() ?\n\nIndice: help(\"read.table\"),help(\"is.na\")\n#1\nA = read.table(file=\"auto2004_original.txt\", sep=\"\\t\", header = TRUE)\n#2\nB = read.table(file=\"auto2004_sans_nom.txt\", sep=\"\\t\", header = FALSE)\n#3\nC = read.table(file=\"auto2004_virgule.txt\", sep=\"\\t\", header = TRUE, dec = \",\")\n#4\nD = read.table(file=\"auto2004_don_manquante.txt\", header = TRUE, sep=\"\\t\", na.strings = \"\")\nnb = length(which(is.na(D) == TRUE))\n#5\nE = read.table(file=\"auto2004_don_manquante(99999).txt\", header = TRUE, sep=\"\\t\", na.strings = \"99999\")\n#6\nclass(E)\n\n\nExercice 10 : Enregistrer des données\nCréer la matrice suivante :\n\\[\nA=\\left[\\begin{array}{cccc}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12\n\\end{array}\\right]\n\\]\n\nEcrire la matrice A dans un fichier nommé matrice.txt. Que remarquez-vous?\nAjouter des arguments à la commande précédente pour retirer des noms aux lignes et aux colonnes du fichier créé.\nSauver la matrice \\(A\\) au format . Rdata dans le fichier matriceA. Rdata grâce à la fonction save.\nQue donne la commande C = load(“matriceA.Rdata”) ?\nSauver toutes les variables dans un fichier nommé “données.Rdata”\n\nA = matrix(seq(12), ncol = 4, byrow = TRUE)\n#1\nwrite.table(A, file = \"matrice.txt\")\n#2\nwrite.table(A, file = \"matrice.txt\", row.names = FALSE, col.names = FALSE)\n#3\nsave(A, file=\"matriceA.Rdata\")\n#4\nC = load(\"matriceA.Rdata\")\n### la matrice A est rechargée.\n### la variable C vaut \"A\"\n#5\nsave(list = ls(), \"données.Rdata\")",
    "crumbs": [
      "Exercices",
      "Lire et sauvegarder des données"
    ]
  },
  {
    "objectID": "exos/read_save_dataset.html#exercice-9-lire-les-données-dun-fichier-fonction-read.table",
    "href": "exos/read_save_dataset.html#exercice-9-lire-les-données-dun-fichier-fonction-read.table",
    "title": "19  Lire et sauvegarder des données",
    "section": "",
    "text": "Importez dans une variable nommée A le jeu de données nommé auto2004_original.txt. \\({ }^{* *}\\) Indice : le séparateur de colonne ‘tabulation’ correspond à “en informatique*\nImportez dans une variable nommée B le jeu de données auto2004_sans_nom.txt.\nImportez dans une variable nommée \\(C\\) le jeu de données auto2004_virgule.txt.\nImportez dans une variable nommée D le jeu de données auto2004_don_manquante.txt. Combien de valeurs manquantes sont contenues dans le fichier?\nImportez dans une variable nommée E le jeu de données auto2004_don_manquante (99999).txt.\nQuel est le mode des objets créés par la fonction read.table() ?\n\nIndice: help(\"read.table\"),help(\"is.na\")\n#1\nA = read.table(file=\"auto2004_original.txt\", sep=\"\\t\", header = TRUE)\n#2\nB = read.table(file=\"auto2004_sans_nom.txt\", sep=\"\\t\", header = FALSE)\n#3\nC = read.table(file=\"auto2004_virgule.txt\", sep=\"\\t\", header = TRUE, dec = \",\")\n#4\nD = read.table(file=\"auto2004_don_manquante.txt\", header = TRUE, sep=\"\\t\", na.strings = \"\")\nnb = length(which(is.na(D) == TRUE))\n#5\nE = read.table(file=\"auto2004_don_manquante(99999).txt\", header = TRUE, sep=\"\\t\", na.strings = \"99999\")\n#6\nclass(E)",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lire et sauvegarder des données</span>"
    ]
  },
  {
    "objectID": "exos/read_save_dataset.html#exercice-10-enregistrer-des-données",
    "href": "exos/read_save_dataset.html#exercice-10-enregistrer-des-données",
    "title": "19  Lire et sauvegarder des données",
    "section": "Exercice 10 : Enregistrer des données",
    "text": "Exercice 10 : Enregistrer des données\nCréer la matrice suivante :\n\\[\nA=\\left[\\begin{array}{cccc}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12\n\\end{array}\\right]\n\\]\n\nEcrire la matrice A dans un fichier nommé matrice.txt. Que remarquez-vous?\nAjouter des arguments à la commande précédente pour retirer des noms aux lignes et aux colonnes du fichier créé.\nSauver la matrice \\(A\\) au format . Rdata dans le fichier matriceA. Rdata grâce à la fonction save.\nQue donne la commande C = load(“matriceA.Rdata”) ?\nSauver toutes les variables dans un fichier nommé “données.Rdata”\n\nA = matrix(seq(12), ncol = 4, byrow = TRUE)\n#1\nwrite.table(A, file = \"matrice.txt\")\n#2\nwrite.table(A, file = \"matrice.txt\", row.names = FALSE, col.names = FALSE)\n#3\nsave(A, file=\"matriceA.Rdata\")\n#4\nC = load(\"matriceA.Rdata\")\n### la matrice A est rechargée.\n### la variable C vaut \"A\"\n#5\nsave(list = ls(), \"données.Rdata\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lire et sauvegarder des données</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_graph.html",
    "href": "exos/fonctions_graph.html",
    "title": "Fonctions graphiques",
    "section": "",
    "text": "Exercice 11 : quelques graphiques de base en \\(R\\)\n\nChargez le jeu de données irisdéjà présent dans \\(R\\).\nPour chaque espèce de fleurs, indiquez le nombre de lignes.\nA partir du résultat précédent, réalisez une représentation en camembert (pie chart), puis en bâtons (barplot). Indice pie()\nTapez la ligne de commande suivante : summary (iris).\n\nQuel résultat obtenez-vous ? 5. Une représentation adéquate est la boîte à moustache (boxplot). Créez un boxplot pour les 4 variables numériques du jeu de données iris. Indice boxplot() 6. Réalisez le même graphique en ajoutant un titre et en supprimant les valeurs extrêmes. 7. Représentez le pie chart et le boxplot sur la même fenêtre graphique. Indice par(), option mfrow. 8. Exportez le graphique précédent en pdf sur votre machine. Indice pdf() ; dev.off() 9. Représenter un scatter plot simple avec en abscisse la longueur des pétales et en ordonnées leur largeur. Indice plot 10. Afin de découvrir les différents paramètres de la fonction plot, refaite le même graphique qu’à la fonction précédente en :\n\naugmentant la taille des points Indice : cex\nremplaçant les points par des triangles de couleur rouge Indice pch option\najoutant une ligne horizontale en pointillé à \\(y=1\\) Indice : abline\n\n#1\ndata(iris)\n#2\np = table(iris$Species)\n#3\npie(p)\nbarplot(p)\n#4\nsummary(iris)\n#5\nboxplot(iris[,1:4])\n#6\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\n#7\npar(mfrow=c(1,2))\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\npie(p)\n#8\npdf(\"plotIris.pdf\")\npar(mfrow=c(1,2))\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\npie(p)\ndev.off()\n#9\nplot(iris$Petal.Length, iris$Petal.Width)\n#10\nplot(iris$Petal.Length, iris$Petal.Width, cex=5)\nplot(iris$Petal.Length, iris$Petal.Width, pch=17, col=\"red\")\nabline(h=1, lty=2)\n#9\npairs(iris[,1:4], col=as.numeric(iris$Species), pch=16)\n#10\npdf(\"pairs_iris.pdf\")\npairs(iris[,1:4], col=as.numeric(iris$Species), pch=16)\ndev.off()\n\n\nExercice 12 : distribution et density plot\n\nCharger le jeu de données airquality.\nPrendre connaissance des données (dimension, type).\nConstruire un histogramme de la variable Ozone. Représenter l’histogramme en terme de probabilité de densité plutôt qu’en terme de fréquence (axe Y). Ajouter un titre, modifier le noms des axes, et colorer les barres de l’histogramme en gris et les traits de l’histogramme en bleu. Augmenter la taille du pas de l’histogramme à 30 .\nRegarder l’aide de la fonction density (). Appliquer cette fonction à la variable Ozone. Cela retourne-t-il une erreur ? Pourquoi ? Corriger la en spécifiant une option.\nAjouter la courbe de densité précédemment générer à l’histogramme. Indice lines()\n\ndata(airquality)\nhist(airquality$Ozone)\nhist(airquality$Ozone, freq=FALSE, main=\"Histogramme Ozone\", xlab=\"Ozone\", ylab=\"Densité\", col = \"gray\"\nhist(airquality$Ozone, freq=FALSE, main=\"Histogramme Ozone\", xlab=\"Ozone\", ylab=\"Densité\", col = \"gray\"\n        breaks=30)\nd = density(airquality$Ozone, na.rm=TRUE)\nlines(d)",
    "crumbs": [
      "Exercices",
      "Fonctions graphiques"
    ]
  },
  {
    "objectID": "exos/fonctions_graph.html#exercice-11-quelques-graphiques-de-base-en-r",
    "href": "exos/fonctions_graph.html#exercice-11-quelques-graphiques-de-base-en-r",
    "title": "20  Fonctions graphiques",
    "section": "",
    "text": "Chargez le jeu de données irisdéjà présent dans \\(R\\).\nPour chaque espèce de fleurs, indiquez le nombre de lignes.\nA partir du résultat précédent, réalisez une représentation en camembert (pie chart), puis en bâtons (barplot). Indice pie()\nTapez la ligne de commande suivante : summary (iris).\n\n\n\naugmentant la taille des points Indice : cex\nremplaçant les points par des triangles de couleur rouge Indice pch option\najoutant une ligne horizontale en pointillé à \\(y=1\\) Indice : abline\n\n#1\ndata(iris)\n#2\np = table(iris$Species)\n#3\npie(p)\nbarplot(p)\n#4\nsummary(iris)\n#5\nboxplot(iris[,1:4])\n#6\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\n#7\npar(mfrow=c(1,2))\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\npie(p)\n#8\npdf(\"plotIris.pdf\")\npar(mfrow=c(1,2))\nboxplot(iris[,1:4], title=\"Iris Boxplot\", outline=FALSE)\npie(p)\ndev.off()\n#9\nplot(iris$Petal.Length, iris$Petal.Width)\n#10\nplot(iris$Petal.Length, iris$Petal.Width, cex=5)\nplot(iris$Petal.Length, iris$Petal.Width, pch=17, col=\"red\")\nabline(h=1, lty=2)\n#9\npairs(iris[,1:4], col=as.numeric(iris$Species), pch=16)\n#10\npdf(\"pairs_iris.pdf\")\npairs(iris[,1:4], col=as.numeric(iris$Species), pch=16)\ndev.off()",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Fonctions graphiques</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_graph.html#exercice-12-distribution-et-density-plot",
    "href": "exos/fonctions_graph.html#exercice-12-distribution-et-density-plot",
    "title": "20  Fonctions graphiques",
    "section": "Exercice 12 : distribution et density plot",
    "text": "Exercice 12 : distribution et density plot\n\nCharger le jeu de données airquality.\nPrendre connaissance des données (dimension, type).\nConstruire un histogramme de la variable Ozone. Représenter l’histogramme en terme de probabilité de densité plutôt qu’en terme de fréquence (axe Y). Ajouter un titre, modifier le noms des axes, et colorer les barres de l’histogramme en gris et les traits de l’histogramme en bleu. Augmenter la taille du pas de l’histogramme à 30 .\nRegarder l’aide de la fonction density (). Appliquer cette fonction à la variable Ozone. Cela retourne-t-il une erreur ? Pourquoi ? Corriger la en spécifiant une option.\nAjouter la courbe de densité précédemment générer à l’histogramme. Indice lines()\n\ndata(airquality)\nhist(airquality$Ozone)\nhist(airquality$Ozone, freq=FALSE, main=\"Histogramme Ozone\", xlab=\"Ozone\", ylab=\"Densité\", col = \"gray\"\nhist(airquality$Ozone, freq=FALSE, main=\"Histogramme Ozone\", xlab=\"Ozone\", ylab=\"Densité\", col = \"gray\"\n        breaks=30)\nd = density(airquality$Ozone, na.rm=TRUE)\nlines(d)",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Fonctions graphiques</span>"
    ]
  },
  {
    "objectID": "exos/loops.html",
    "href": "exos/loops.html",
    "title": "Manipulation des boucles",
    "section": "",
    "text": "Exercice 13: for\n\nLisez l’aide sur la procédure permettant de réaliser des boucles indicées for (help(“for”)). Remarque : demander de l’aide sur cette procédure avec la syntaxe ?for ne fonctionnera pas! Pourquoi?\nCréer une boucle qui affiche l’indice i de l’itération en cours (10 itérations)\nA l’aide d’une boucle, calculez la somme des entiers pairs compris entre 1 et 100 .\n\n#1\nhelp(\"for\")\n#2\nfor (i in 1:10) print(i)\n#3\nsomme = 0\nfor (i in seq(2,100,2)) {\n    somme = somme + i\n}\nsomme\n\n\nExercice 14 : for, if et else\n\nComme dans l’exercice précédent, lisez l’aide de la procédure conditionnelle if : (help(“if”)).\nUtilisez les structures if et else pour créer un programme qui prend en entrée un réel \\(x\\) et qui lui associe \\(y=x^{2}\\) si \\(x\\) est strictement positif et \\(y=x^{3}\\) si \\(x\\) est négatif ou nul. Testez pour les valeurs \\(x=\\) \\(25,-2,12\\) et 0 .\nUtilisez les structures if et else pour créer un programme qui imprime à l’écran, pour chaque entier relatif \\(i\\) compris entre -10 et \\(10, i^{3}\\) si \\(i&lt;=0\\), ou \\(i^{2}\\) si \\(i&gt;0\\).\n\n#1\nhelp(\"if\")\n#2\nx = 25\ny = 0\nif (x &gt; 0){\n    y = x^2\n}\nelse{\n    y = x^3\n}\n#3\nfor (i in -10:10){\n    x = i\n    y = 0\n    if (x &gt; 0){\n        y = x^2\n    }\n    else{\n        y = x^3\n    }\n    print(paste(i, y, sep=\" =&gt; \"))\n}\n\n\nExercice 15 : un moyen plus rapide de faire des boucles !\n\nCréer une matrice matrice contenant des valeurs tirées aléatoirement de dimension 10 lignes x 10 colonnes et dont les éléments suivent une loi normale de moyenne nulle et de variance 2.32 .\nAfficher nombre d’éléments positifs et négatifs de la matrice. Remplacer les nombre négatifs par 0 .\nAfficher les marges de matrice (sommes des valeurs en lignes et en colonnes). Indice : apply, sum\nAfficher la moyenne des lignes et des colonnes de la matrice.\nUn autre moyen d’afficher rapidemment la somme/moyenne des lignes/colonnes d’une matrice, est d’utiliser des fonctions R pré-existantes : rowSums, colSums, rowMeans, colMeans.\n\n#1\nmatrice = matrix(rnorm(n=100, mean = 0, sd = 2.32),nrow = 10, ncol=10)\n#2\nnbPos = length(which(matrice &gt; 0))\nidxNeg = which(matrice &lt; 0)\nnbNeg = length(idxNeg)\nmatrice[idxNeg] = 0\n#3\napply(matrice, 1, sum)\napply(matrice, 2, sum)\n#4\napply(matrice, 1, mean)\napply(matrice, 1, mean)\n#5\nrowSums(matrice); colSums(matrice)\nrowMeans(matrice); colMeans(matrice)",
    "crumbs": [
      "Exercices",
      "Manipulation des boucles"
    ]
  },
  {
    "objectID": "exos/loops.html#exercice-13-for",
    "href": "exos/loops.html#exercice-13-for",
    "title": "21  Manipulation des boucles",
    "section": "",
    "text": "Lisez l’aide sur la procédure permettant de réaliser des boucles indicées for (help(“for”)). Remarque : demander de l’aide sur cette procédure avec la syntaxe ?for ne fonctionnera pas! Pourquoi?\nCréer une boucle qui affiche l’indice i de l’itération en cours (10 itérations)\nA l’aide d’une boucle, calculez la somme des entiers pairs compris entre 1 et 100 .\n\n#1\nhelp(\"for\")\n#2\nfor (i in 1:10) print(i)\n#3\nsomme = 0\nfor (i in seq(2,100,2)) {\n    somme = somme + i\n}\nsomme",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Manipulation des boucles</span>"
    ]
  },
  {
    "objectID": "exos/loops.html#exercice-14-for-if-et-else",
    "href": "exos/loops.html#exercice-14-for-if-et-else",
    "title": "21  Manipulation des boucles",
    "section": "Exercice 14 : for, if et else",
    "text": "Exercice 14 : for, if et else\n\nComme dans l’exercice précédent, lisez l’aide de la procédure conditionnelle if : (help(“if”)).\nUtilisez les structures if et else pour créer un programme qui prend en entrée un réel \\(x\\) et qui lui associe \\(y=x^{2}\\) si \\(x\\) est strictement positif et \\(y=x^{3}\\) si \\(x\\) est négatif ou nul. Testez pour les valeurs \\(x=\\) \\(25,-2,12\\) et 0 .\nUtilisez les structures if et else pour créer un programme qui imprime à l’écran, pour chaque entier relatif \\(i\\) compris entre -10 et \\(10, i^{3}\\) si \\(i&lt;=0\\), ou \\(i^{2}\\) si \\(i&gt;0\\).\n\n#1\nhelp(\"if\")\n#2\nx = 25\ny = 0\nif (x &gt; 0){\n    y = x^2\n}\nelse{\n    y = x^3\n}\n#3\nfor (i in -10:10){\n    x = i\n    y = 0\n    if (x &gt; 0){\n        y = x^2\n    }\n    else{\n        y = x^3\n    }\n    print(paste(i, y, sep=\" =&gt; \"))\n}",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Manipulation des boucles</span>"
    ]
  },
  {
    "objectID": "exos/loops.html#exercice-15-un-moyen-plus-rapide-de-faire-des-boucles",
    "href": "exos/loops.html#exercice-15-un-moyen-plus-rapide-de-faire-des-boucles",
    "title": "21  Manipulation des boucles",
    "section": "Exercice 15 : un moyen plus rapide de faire des boucles !",
    "text": "Exercice 15 : un moyen plus rapide de faire des boucles !\n\nCréer une matrice matrice contenant des valeurs tirées aléatoirement de dimension 10 lignes x 10 colonnes et dont les éléments suivent une loi normale de moyenne nulle et de variance 2.32 .\nAfficher nombre d’éléments positifs et négatifs de la matrice. Remplacer les nombre négatifs par 0 .\nAfficher les marges de matrice (sommes des valeurs en lignes et en colonnes). Indice : apply, sum\nAfficher la moyenne des lignes et des colonnes de la matrice.\nUn autre moyen d’afficher rapidemment la somme/moyenne des lignes/colonnes d’une matrice, est d’utiliser des fonctions R pré-existantes : rowSums, colSums, rowMeans, colMeans.\n\n#1\nmatrice = matrix(rnorm(n=100, mean = 0, sd = 2.32),nrow = 10, ncol=10)\n#2\nnbPos = length(which(matrice &gt; 0))\nidxNeg = which(matrice &lt; 0)\nnbNeg = length(idxNeg)\nmatrice[idxNeg] = 0\n#3\napply(matrice, 1, sum)\napply(matrice, 2, sum)\n#4\napply(matrice, 1, mean)\napply(matrice, 1, mean)\n#5\nrowSums(matrice); colSums(matrice)\nrowMeans(matrice); colMeans(matrice)",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Manipulation des boucles</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html",
    "href": "exos/fonctions_perso.html",
    "title": "Créer et utiliser ses propres fonctions",
    "section": "",
    "text": "Exercice 16 : notre première fonction\n\nExécutez les commandes data(iris) puis str (iris). Nous venons de charger en mémoire l’un des nombreux jeux de données distribués avec \\(R\\) ! Profitez de l’aide sur ce jeu de données pour en apprendre un peu plus sur les fleurs (?iris)! Tous les jeux de données disponibles avec l’installation de base de \\(R\\) sont accessibles en tapant data().\nCréez la fonction moyenneET suivante et décryptez la: moyenneET \\(=\\) function(i) \\(c(m o y=m e a n(i r i s[, i]), ~ e t=s d(i r i s[, i]))\\)\nAfficher l’aide de la fonction apply. En utilisant cette fonction, calculez la moyenne et l’écart type des colonnes numériques du dataset iris. Comparer le résultat avec celui obtenu par la foncion moyenneET.\n\nRemarque : pour exécuter plusieurs commandes au sein d’une même fonction, il faut utiliser des accolades {…}.\n#1\ndata(iris)\nstr(iris)\nmoyenneET(2)\n#2\nmoyenneET &lt;- function(i) {\n    moy = mean(iris[,i])\n    et = sd(iris[,i])\n    return( c(moy = moy, et = et) )\n}\n#3\n?apply\nmoy = apply(iris[,c(1,2,3,4)], 2, mean)\net = apply(iris[,c(1,2,3,4)], 2, sd)\nmoyenneET(1)\nmoyenneET(2)\nmoyenneET(3)\nmoyenneET(4)\n\n\nExercice 17 : une autre fonction toute simple\nCréer une fonction nommée somme qui calcule la somme de deux variables x et y passées en arguments.\nsomme = function(x, y){\n    resultat = x+y\n    return(resultat)\n}\n\n\nExercice 18 : Nombre mystère\n\nChoisir un nombre mystère entre 1 et 100 , et le stocker dans un objet que l’on nommera nombre_mystere. Ensuite, créer une boucle qui à chaque itération effectue un tirage aléatoire d’un entier compris entre 1 et 100 . Tant que le nombre tiré est différent du nombre mystère, la boucle doit continuer. A la sortie de la boucle, une variable que l’on appellera nb_tirages contiendra le nombre de tirages réalisés pour obtenir le nombre mystère.\nUtiliser le code de la question précédente pour réaliser la fonction trouver_nombre, qui, lorsqu’on lui donne un nombre compris entre 1 et 100, retourne le nombre de tirages aléatoires d’entiers compris entre 1 et 100 nécessaires avant de tirer le nombre mystère.\nEn utilisant une boucle for, faire appel 1000 fois à la fonction trouver_nombre() qui vient d’être créée. A chaque itération, stocker le résultat dans un élément d’un vecteur que l’on appellera nb_essais_rep. Enfin, afficher la moyenne du nombre de tirages nécessaires pour retrouver le nombre magique.\n\nIndice: sample, while\n# 1\nnombre_mystere = 59\ns = 0\nnb_tirages = 0\nwhile (s != nombre_mystere){\n    s = sample(1:100, 1)\n    nb_tirages = nb_tirages + 1\n}\nnb_tirages\n# 2\ntrouver_nombre = function(nombre_mystere){\n    if (nombre_mystere &gt;=1 & nombre_mystere &lt;=100){\n        s = 0\n        nb_tirages = 0\n        while (s != nombre_mystere){\n            s = sample(1:100, 1)\n            nb_tirages = nb_tirages + 1\n        }\n        nb_tirages\n    }\n    else{\n        warning(\"Votre nombre doit être compris entre 1 et 100\")\n    }\n}\n#3\nnb_essais_rep = c()\nfor (i in seq(1000)){\n    tmp = trouver_nombre(39)\n    nb_essais_rep = c(nb_essais_rep, tmp)\n}\nmean(tmp)\n\n\nExercice 19 : Création d’une fonction, traitement de chaines de caractères\nSupposons que les adresses e-mails des étudiants de centralsupelec soient constituées de la manière suivante: le prénom et le nom de famille séparés par un point, le symbole arobase et enfin le nom de domaine. Supposons de plus que les étudiants ont un seul prénom, et aucune particule au nom de famille. La syntaxe des adresses e-mail est donc comme suit : nom.prenom@etudiant.centralsupelec.fr.\n\nCréer une fonction parseMail, qui à partir d’une adresse e-mail d’un étudiant, retourne un data.frame contenant trois variables : le prénom, le nom et l’adresse e-mail de cet étudiant.\nUtiliser cete fonction pour créer un data.frame emails.df à partir du vecteur emails, contenant tous les prénoms, noms et adresses e-mail des étudiants indice : strsplit\n\nemails = c( \"john.snow@etudiant.centralsupelec.fr\",\n\"patti.smith@etudiant.centralsupelec.fr\",\n    \"rick.grimes@etudiant.centralsupelec.fr\",\n    \"mere.theresa@etudiant.centralsupelec.fr\")\n#1\nparseMail = function(email){\n    nom_prenom = unlist(strsplit(email, \"@\"))[1]\n    nom_prenom = unlist(strsplit(nom_prenom, \"\\\\.\"))\n    prenom = nom_prenom[1]\n    nom = nom_prenom[2]\n    data.frame(prenom = prenom, nom = nom, email = email)\n}\n#2\nemails.df = c()\nfor (m in emails){\n    df = parseMail(m)\n    emails.df = rbind(emails.df,df)\n}\n\n\nExercice 20 : Fonctions appliquées aux éléments d’une liste\nSoit une liste nommée twittos, disponible à l’adresse suivante : https://pf-bb.github.io/CentraleSupelec-R-genomics/ Elle contient des informations fictives sur des utilisateurs de Twitter ; chaque élément de cette liste est une liste dont les éléments sont les suivants:\n\nscreen_name: nom d’utilisateur\nnb_tweets: nombre de tweets\nnb_followers: nombre de followers\nnb_friends: nombre de followings\ncreated_at: date de création du compte\nlocation: ville renseignée\n\n\nImporter le contenu du fichier dans la session \\(R\\)\nUtiliser la fonction lapply() sur twittos pour récupérer une liste contenant uniquement les noms d’utilisateurs. Faire de même pour le nombre de followers, puis appliquer unlist() au résultat.\nCréer une fonction qui, quand on lui fournit un élément de la liste twittos, c’est-à-dire les informations sous forme de liste d’un seul utilisateur, retourne ces informations sous forme de tableau de données. Nommer cette fonction twittos_to_df.\nAppliquer la fonction twittos_to_df() au premier élément de la liste twittos, puis utiliser la fonction lapply() pour appliquer la fonction twittos_to_df() à tous les éléments de la liste. Stocker ce dernier résultat dans un objet appelé res\nQuelle est la structure de l’objet res obtenu à la question précédente ?\n\n#1\nload(\"twittos.rda\")\n#2\nlapply(twittos, function(twit){twit$screen_name})\n#3\ntwittos_to_df = function(twit){\n    return(data.frame(twit))\n}\n#4\ntwittos_to_df(twittos[1])\nres = lapply(twittos, twittos_to_df)",
    "crumbs": [
      "Exercices",
      "Créer et utiliser ses propres fonctions"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html#exercice-16-notre-première-fonction",
    "href": "exos/fonctions_perso.html#exercice-16-notre-première-fonction",
    "title": "22  Créer et utiliser ses propres fonctions",
    "section": "",
    "text": "Exécutez les commandes data(iris) puis str (iris). Nous venons de charger en mémoire l’un des nombreux jeux de données distribués avec \\(R\\) ! Profitez de l’aide sur ce jeu de données pour en apprendre un peu plus sur les fleurs (?iris)! Tous les jeux de données disponibles avec l’installation de base de \\(R\\) sont accessibles en tapant data().\nCréez la fonction moyenneET suivante et décryptez la: moyenneET \\(=\\) function(i) \\(c(m o y=m e a n(i r i s[, i]), ~ e t=s d(i r i s[, i]))\\)\nAfficher l’aide de la fonction apply. En utilisant cette fonction, calculez la moyenne et l’écart type des colonnes numériques du dataset iris. Comparer le résultat avec celui obtenu par la foncion moyenneET.\n\n\n#1\ndata(iris)\nstr(iris)\nmoyenneET(2)\n#2\nmoyenneET &lt;- function(i) {\n    moy = mean(iris[,i])\n    et = sd(iris[,i])\n    return( c(moy = moy, et = et) )\n}\n#3\n?apply\nmoy = apply(iris[,c(1,2,3,4)], 2, mean)\net = apply(iris[,c(1,2,3,4)], 2, sd)\nmoyenneET(1)\nmoyenneET(2)\nmoyenneET(3)\nmoyenneET(4)",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Créer et utiliser ses propres fonctions</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html#exercice-17-une-autre-fonction-toute-simple",
    "href": "exos/fonctions_perso.html#exercice-17-une-autre-fonction-toute-simple",
    "title": "22  Créer et utiliser ses propres fonctions",
    "section": "Exercice 17 : une autre fonction toute simple",
    "text": "Exercice 17 : une autre fonction toute simple\nCréer une fonction nommée somme qui calcule la somme de deux variables x et y passées en arguments.\nsomme = function(x, y){\n    resultat = x+y\n    return(resultat)\n}",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Créer et utiliser ses propres fonctions</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html#exercice-18-nombre-mystère",
    "href": "exos/fonctions_perso.html#exercice-18-nombre-mystère",
    "title": "22  Créer et utiliser ses propres fonctions",
    "section": "Exercice 18 : Nombre mystère",
    "text": "Exercice 18 : Nombre mystère\n\nChoisir un nombre mystère entre 1 et 100 , et le stocker dans un objet que l’on nommera nombre_mystere. Ensuite, créer une boucle qui à chaque itération effectue un tirage aléatoire d’un entier compris entre 1 et 100 . Tant que le nombre tiré est différent du nombre mystère, la boucle doit continuer. A la sortie de la boucle, une variable que l’on appellera nb_tirages contiendra le nombre de tirages réalisés pour obtenir le nombre mystère.\nUtiliser le code de la question précédente pour réaliser la fonction trouver_nombre, qui, lorsqu’on lui donne un nombre compris entre 1 et 100, retourne le nombre de tirages aléatoires d’entiers compris entre 1 et 100 nécessaires avant de tirer le nombre mystère.\nEn utilisant une boucle for, faire appel 1000 fois à la fonction trouver_nombre() qui vient d’être créée. A chaque itération, stocker le résultat dans un élément d’un vecteur que l’on appellera nb_essais_rep. Enfin, afficher la moyenne du nombre de tirages nécessaires pour retrouver le nombre magique.\n\nIndice: sample, while\n# 1\nnombre_mystere = 59\ns = 0\nnb_tirages = 0\nwhile (s != nombre_mystere){\n    s = sample(1:100, 1)\n    nb_tirages = nb_tirages + 1\n}\nnb_tirages\n# 2\ntrouver_nombre = function(nombre_mystere){\n    if (nombre_mystere &gt;=1 & nombre_mystere &lt;=100){\n        s = 0\n        nb_tirages = 0\n        while (s != nombre_mystere){\n            s = sample(1:100, 1)\n            nb_tirages = nb_tirages + 1\n        }\n        nb_tirages\n    }\n    else{\n        warning(\"Votre nombre doit être compris entre 1 et 100\")\n    }\n}\n#3\nnb_essais_rep = c()\nfor (i in seq(1000)){\n    tmp = trouver_nombre(39)\n    nb_essais_rep = c(nb_essais_rep, tmp)\n}\nmean(tmp)",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Créer et utiliser ses propres fonctions</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html#exercice-19-création-dune-fonction-traitement-de-chaines-de-caractères",
    "href": "exos/fonctions_perso.html#exercice-19-création-dune-fonction-traitement-de-chaines-de-caractères",
    "title": "22  Créer et utiliser ses propres fonctions",
    "section": "Exercice 19 : Création d’une fonction, traitement de chaines de caractères",
    "text": "Exercice 19 : Création d’une fonction, traitement de chaines de caractères\nSupposons que les adresses e-mails des étudiants de centralsupelec soient constituées de la manière suivante: le prénom et le nom de famille séparés par un point, le symbole arobase et enfin le nom de domaine. Supposons de plus que les étudiants ont un seul prénom, et aucune particule au nom de famille. La syntaxe des adresses e-mail est donc comme suit : nom.prenom@etudiant.centralsupelec.fr.\n\nCréer une fonction parseMail, qui à partir d’une adresse e-mail d’un étudiant, retourne un data.frame contenant trois variables : le prénom, le nom et l’adresse e-mail de cet étudiant.\nUtiliser cete fonction pour créer un data.frame emails.df à partir du vecteur emails, contenant tous les prénoms, noms et adresses e-mail des étudiants indice : strsplit\n\nemails = c( \"john.snow@etudiant.centralsupelec.fr\",\n\"patti.smith@etudiant.centralsupelec.fr\",\n    \"rick.grimes@etudiant.centralsupelec.fr\",\n    \"mere.theresa@etudiant.centralsupelec.fr\")\n#1\nparseMail = function(email){\n    nom_prenom = unlist(strsplit(email, \"@\"))[1]\n    nom_prenom = unlist(strsplit(nom_prenom, \"\\\\.\"))\n    prenom = nom_prenom[1]\n    nom = nom_prenom[2]\n    data.frame(prenom = prenom, nom = nom, email = email)\n}\n#2\nemails.df = c()\nfor (m in emails){\n    df = parseMail(m)\n    emails.df = rbind(emails.df,df)\n}",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Créer et utiliser ses propres fonctions</span>"
    ]
  },
  {
    "objectID": "exos/fonctions_perso.html#exercice-20-fonctions-appliquées-aux-éléments-dune-liste",
    "href": "exos/fonctions_perso.html#exercice-20-fonctions-appliquées-aux-éléments-dune-liste",
    "title": "22  Créer et utiliser ses propres fonctions",
    "section": "Exercice 20 : Fonctions appliquées aux éléments d’une liste",
    "text": "Exercice 20 : Fonctions appliquées aux éléments d’une liste\nSoit une liste nommée twittos, disponible à l’adresse suivante : https://pf-bb.github.io/CentraleSupelec-R-genomics/ Elle contient des informations fictives sur des utilisateurs de Twitter ; chaque élément de cette liste est une liste dont les éléments sont les suivants:\n\nscreen_name: nom d’utilisateur\nnb_tweets: nombre de tweets\nnb_followers: nombre de followers\nnb_friends: nombre de followings\ncreated_at: date de création du compte\nlocation: ville renseignée\n\n\nImporter le contenu du fichier dans la session \\(R\\)\nUtiliser la fonction lapply() sur twittos pour récupérer une liste contenant uniquement les noms d’utilisateurs. Faire de même pour le nombre de followers, puis appliquer unlist() au résultat.\nCréer une fonction qui, quand on lui fournit un élément de la liste twittos, c’est-à-dire les informations sous forme de liste d’un seul utilisateur, retourne ces informations sous forme de tableau de données. Nommer cette fonction twittos_to_df.\nAppliquer la fonction twittos_to_df() au premier élément de la liste twittos, puis utiliser la fonction lapply() pour appliquer la fonction twittos_to_df() à tous les éléments de la liste. Stocker ce dernier résultat dans un objet appelé res\nQuelle est la structure de l’objet res obtenu à la question précédente ?\n\n#1\nload(\"twittos.rda\")\n#2\nlapply(twittos, function(twit){twit$screen_name})\n#3\ntwittos_to_df = function(twit){\n    return(data.frame(twit))\n}\n#4\ntwittos_to_df(twittos[1])\nres = lapply(twittos, twittos_to_df)",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Créer et utiliser ses propres fonctions</span>"
    ]
  },
  {
    "objectID": "exos/togofurther.html",
    "href": "exos/togofurther.html",
    "title": "Exercices de Niveau Avancé",
    "section": "",
    "text": "Exercice 21 : Layout\nLes données old faithful geyser ont été collectées dans le cadre d’une étude du temps d’attente entre deux éruptions et la durée des éruptions au sein du parc National de Yellowstone (USA). Ce jeu de données est disponible sous \\(R\\) et est nommé faithful (package datasets). Le seuil critique d’attente au delà duquel la probabilité que la prochaine éruption soit longue et forte est fixé à 63 .\n\nTélécharger et visualiser le jeu de données (fonction plot( )), en affichant également la limite des 63 secondes.\nCalculer un vecteur vec de 100000 points correspondant à la loi normale de moyenne \\(m\\) et d’écart type sd correspondant à la moyenne, et à l’écart type, des durées d’éruption.\nConstruire un histogramme de la durée d’éruption. Représenter l’histogramme en terme de densité plutã’t qu’en terme d’effectifs (axe Y). Ajouter un titre, nommer les axes et colorer les barres de l’histogramme en vert et les traits de l’histogramme en rouge. Augmenter la taille du pas de l’histogramme à 20 .\nAjouter la densité du vecteur de point vec à l’histogramme (Indice : lines(), density(). Que remarquez-vous ?\nAfin de mieux apprehender la distribution des données, il est possible d’afficher plusieurs graphiques sur une m \\(\\tilde{A}^{\\text {a }}\\) me grille. L’objectif de cette partie est d’afficher le scatterplot de la question 1, et au dessus et sur la droite, les histogrammes des variables “eruption” et “waiting”, respectivement. Pour cela, nous utiliserons la fonction layout(). 5.1 Créer la matrice suivante :\n\nlayMat = matrix(c(2,0,1,3), ncol=2, byrow=TRUE)\nlayMat\n## [,1] [,2]\n## [1,] 2 0\n## [2,] 1 3\nCette matrice permettra à la fonction layout d’afficher les prochains plot :\n\nen bas à gauche\nen haut à gauche\nen bas à droite (n.b : le chiffre 0 indique qu’aucun plot ne pourra \\(\\tilde{\\mathrm{A}}^{\\text {a }}\\) tre affiché dans cette zone) 5.2 Utiliser la fonction layout et la matrice layMat pour créer une grille d’affichage ayant les proportions suivantes, puis afficher le résultats (indice : layout.show()) :\npremière colonne : \\(70 \\%\\) de la largeur totale\ndeuxième colonne : \\(30 \\%\\) de la largeur totale\npremière ligne : \\(30 \\%\\) de la largeur totale\ndeuxième ligne : \\(70 \\%\\) de la largeur totale 5.3 Afficher sur ce layout les 3 graphiques suivants:\nle scatter plot de la question 1\nl’histogramme de la variable “eruption”\nl’histogramme de la variable “waiting” (indice : pensez à mettre l’hitogramme à l’horizontal)\n\n#1\ndata(faithful)\n?faithful\nplot(faithful$waiting, faithful$eruptions)\nabline(v=63, col=\"red\")\n#2\nvec = rnorm(100000, mean = mean(faithful$eruptions), sd = sd(faithful$eruptions))\n#3\nhist(faithful$eruptions, freq = FALSE, main = \"Histogramme de la durée des eruptions\", xlab = \"Durée de\n#4\nlines(density(vec))\n#5\n#5.1\nlayMat = matrix(c(2,0,1,3), ncol=2, byrow=TRUE)\n#5.2\nlayout(layMat, widths=c(0.7, 0.3), heights=c(0.3, 0.7 ))\nlayout.show(n=3)\n    ## scatter plot\nplot(faithful, xlim=range(faithful$eruptions), ylim=range(faithful$waiting))\nxhist = hist(faithful$eruptions, plot=FALSE, breaks=20)\nyhist = hist(faithful$waiting , plot=FALSE, breaks=20)\nbarplot(xhist$density, axes=FALSE, space=0)\nbarplot(yhist$density, axes=FALSE, space=0, horiz=TRUE)\n\n\nExercice 22: ah si j’étais riche !\nUn ami vous propose le jeu suivant. On lance un dé. Si le résultat est 5 ou 6 , on gagne \\(3 €\\), si le résultat est 4 on gagne \\(1 €\\) et si c’est 3 ou moins on perd \\(2.5 €\\). Avant d’accepter la partie, vous essayez de simuler ce jeu, pour voir si vous avez des chances de vous enrichir.\n\nCréer une fonction simul qui prend comme argument un entier compris entre 1 et 6 , et qui retourne la somme correspondante.\nCréer un vecteur tirage, simulant le résultat de 1000 tirages de dés.\nAfficher sur un graphique la simulation du jeu.\n\nConclusion?\n#1\nsimul = function(i){\n    res = NULL\n    if (i &lt;= 6 && i &gt;= 1){\n        res = switch(i, -2.5, -2.5, -2.5, 1, 3, 3)\n    }\n    else {\n        warning(\"Un tirage de dès en peut donner qu'un chiffre entre 1 et 6\")\n    }\n    return(res)\n}\n#2\ntirage = sample(x = c(1:6),size = 1000, replace = TRUE )\n#3\nresultat = sapply(tirage, simul)\ngain = cumsum(resultat)\nplot(gain)\n\n\nExercice 23 : James Bond autour du monde\nR contient de nombreux packages nous permettant de faire des représentations graphiques de toutes sortes. Certains packages permettent de faire des représentations spatiales (rgdal, sp, rgeos,cartography). Connu comme une boite à outil dédiée à la cartographie thématique, le package cartography est développé au sein de l’UMS RIATE (CNRS, CGET, Université Paris Diderot) par Nicolas Lambert et Timothée Giraud.\nCommencez par installer le package cartograpgy disponible sur le CRAN (via l’utilitaire RStudio ou en ligne de commande).\nNous allons construire une carte dont l’objectif sera de montrer le nombre de fois où 007 s’est rendu dans chaque pays.\nPour cela, télécharger les données disponibles à l’adresse suivante : http://wukan.ums-riate.fr/bond/bondfiles. RData. Nous avons chargé 2 objets :\n\nLe data frame BondVisits contient 2 colonnes, l’identifiant des pays (ISO2) et le nombre de visites (n).\nLa liste WorldCountries : cette liste est une SpatialPolygonsDataFrame (spdf) contenant la carte de tous les pays du monde.\n\n\nAfficher la carte du monde grÃcce à la fonction plot, qui prend en argument des données au format spdf, avec l’arrière plan en gris. On voit que les marges de la figures sont trop grandes. Modifiez les pour maximiser l’espace pris par la map monde. Redessinez la map monde. Indice par() option mar\nAjouter les cercles proportionnels correspondant aux nombres de visites dans chaque pays de 007, avec la couleur de votre choix et des bords blanc. Modifier le titre de la légende de “n” à “Nombres de visites”.\nOn veut à présent représenter le nombres de visites par des couches de couleurs différentes plutôt que par des symboles proportionnels. Quelle fonction doit-on utiliser ? Appliquer la fonction aux données. Le résultat obtenu vous parait-il correct?\nRegarder le contenu de l’objet WorldCountries@data. Construisez un nouveau dataframe contenant tous les pays et les nombres de visites (NA ou 0 si inconnu). Réessayez de créer le graphique de la question précédente. Indice : pour créer le nouveau dataframe, la fonction merge peut vous être utile\n\nlibrary(cartography)\nload((url(\"http://wukan.ums-riate.fr/bond/bondfiles.RData\")))\nhead(BondVisits)\nplot(WorldCountries, bg=\"gray\")\npar(mar = c(0,0,1.2,0))\nplot(WorldCountries, bg=\"gray\")\npropSymbolsLayer(spdf = WorldCountries, df = BondVisits, var=\"n\", border=\"white\", col=\"magenta3\", legen\nchoroLayer(spdf = WorldCountries, df = BondVisits, var=\"n\")\nBondVisits2 = merge(BondVisits, WorldCountries@data, by=\"ISO2\", all.y=TRUE)\nchoroLayer(spdf = WorldCountries, df = BondVisits2, var=\"n\", legend.title.txt = \"Nombre de visites\")\n\n\nExercice 24 : Profil CGH\nLes technologies de génomique permettent de détecter des abérrations au niveau de notre génome (CNA - Copy Number Alteration) : duplication, remaniement, translocation, perte, etc … En cancérologie, le génome des tumeurs est souvent anormal (voir la figure “Profil CGH”).\nCet exercice a pour objectif de reconstruire ce profil à partir du package “chromosomes” (développé par B. Job, Gustave Roussy) et du jeu de données A01.ASPCF, issu de l’analyse par des microarrays du type “Oncoscan” (Affymetrix) de la tumeur d’un patient.\n\nInstaller le package ‘chromosomes_1.0-0.tgz’ (ce fichier est récupérable sur le site du TP). Charger le package avec la commande library(); Enfin, charger le dataset hg19. Ceci importe dans votre session \\(R\\) une variable nommée cs (chromosome structure) décrivant les positions du génome humaine (version hg19).\n\n\n\nQuelle est la classe de la variable cs ?\nCombien le génome contient-il de chromosomes? (Indice : parcourir l’obet cs avec la fonction str)\nQuelle est la taille du génome humain (dans sa version hg19) ?\n\n\n\nCharger le fichier A01. ascat. ASPCF.RDS dans la variable cgh\n\n\n\nQuelle est la classe de la variable cgh ?\nCombien d’éléments contient cette variable ?\nQuelle est le genre du patient à qui correspond le profil?\n\n\n\nConstruction du profil CNA \n\nFigure 1: Profil CGH a. Construction des vecteurs de points à afficher depuis la variable cgh :\n\nCréer le vecteur tumor_lr à partir de la variable cgh\nCréer le vecteur x_snp contenant les positions génomique des points de mesure\nCréer le vecteur x_chr contenant les nom des chromosomes auxquels appartiennent les points de mesure\nCréer le vecteur all_chr contenant une seule occurrence de ces noms de chromosomes\n\n\nEn utilisant la variable cs, construisez le vecteur chr_length, contenant les longueurs des chromosomes. Utiliser la fonction names et la variable cs pour nommer tous les éléments du vecteur chr_length.\nConvertir les positions relatives au chromosome du vecteur \\(x_{-}\\)snp en position absolue sur le génome (vecteur x_snp_abs)\nAfin d’afficher une version lissée du signal mesuré, calculer la “running médiane” (Indice : fonction runmed) à partir du vecteur l2r_tumor\nA partir de ces vecteurs, essayez de reproduire l’image suivante.\n\nIndice: les lignes vertes correspondent à la moyenne des valeurs absolues des différences mesurées entre deux sondes\n#1\ninstall.packages(\"chromosomes_1.0-0.tar.gz\", repos = NULL, type = \"source\")\nlibrary(\"chromosomes\")\ndata(hg19)\n#1.1\nclass(cs)\n#1.2\nstr(cs)\nlength(cs$chromosomes$chrom)\n\nFigure 2: Ebauche de Profil CGH\n#1.3\nstr(cs)\ncs$genome.length\n#2\ncgh = readRDS(file = \"data/A01.ascat.ASPCF.RDS\")\n#2.1\nclass(cgh)\n#2.2\nlength(cgh)\n#2.3\ncgh$gender\n#3.1\ny_tumor_12r = cgh$Tumor_LogR[,1]\nx_snp = as.numeric(as.vector(cgh$SNPpos$pos))\nx_chr = as.vector(cgh$SNPpos$chrs)\nall_chr = unique(x_chr)\n#3.2\nchr_length = cs$chromosomes$chr.length.toadd\nchr_names = cs$chromosomes$chrN\nnames(chr_length) = chr_names\n#3.3\nx_snp_abs = x_snp\nfor (i in all_chr){\n    idx = which(x_chr == i)\n    if (i == \"X\") { tmp.chr = 23}\n    else if (i == \"Y\") { tmp.chr = 24}\n    else { tmp.chr = as.numeric(i)}\n    valtoadd = chr_length[tmp.chr]\n    x_snp_abs[idx] = x_snp_abs[idx] + valtoadd\n}\n#3.4\nl2r_runmed = runmed(y_tumor_l2r , k = 301)\n#3.5\nplot(x_snp_abs, y_tumor_l2r, ylim = c(-2, 2),col = \"gray\", pch = \".\", ylab = \"Log2R\", xlab = \"\", axes =\naxis(2)\npoints(x_snp_abs, l2r_runmed, col=\"blue\", pch = \".\")\nabline(h = 0, lty = 2, col = \"red\")\nabline(v = c(0,cs$chromosomes$chr.length.sum), lty = 2, col = \"black\")\nbox(lwd = 2)\ntmp = mean(abs(diff(y_tumor_12r)))\nabline(h = c(-tmp, tmp), lty = 2, col = \"darkgreen\")\npair = seq(from = 2, to = 24, by = 2)\nimpair = seq(from = 1, to = 23, by = 2)\ntext(x = cs$chromosomes$mid.chr[pair] + cs$chromosomes$chr.length.toadd[pair], y = 1.7 , labels = a\ntext(x = cs$chromosomes$mid.chr[impair] + cs$chromosomes$chr.length.toadd[impair], y = -1.7, labels = a",
    "crumbs": [
      "Exercices",
      "Exercices de Niveau Avancé"
    ]
  },
  {
    "objectID": "exos/togofurther.html#exercice-21-layout",
    "href": "exos/togofurther.html#exercice-21-layout",
    "title": "23  Exercices de Niveau Avancé",
    "section": "",
    "text": "Télécharger et visualiser le jeu de données (fonction plot( )), en affichant également la limite des 63 secondes.\nCalculer un vecteur vec de 100000 points correspondant à la loi normale de moyenne \\(m\\) et d’écart type sd correspondant à la moyenne, et à l’écart type, des durées d’éruption.\nConstruire un histogramme de la durée d’éruption. Représenter l’histogramme en terme de densité plutã’t qu’en terme d’effectifs (axe Y). Ajouter un titre, nommer les axes et colorer les barres de l’histogramme en vert et les traits de l’histogramme en rouge. Augmenter la taille du pas de l’histogramme à 20 .\nAjouter la densité du vecteur de point vec à l’histogramme (Indice : lines(), density(). Que remarquez-vous ?\nAfin de mieux apprehender la distribution des données, il est possible d’afficher plusieurs graphiques sur une m \\(\\tilde{A}^{\\text {a }}\\) me grille. L’objectif de cette partie est d’afficher le scatterplot de la question 1, et au dessus et sur la droite, les histogrammes des variables “eruption” et “waiting”, respectivement. Pour cela, nous utiliserons la fonction layout(). 5.1 Créer la matrice suivante :\n\nlayMat = matrix(c(2,0,1,3), ncol=2, byrow=TRUE)\nlayMat\n## [,1] [,2]\n## [1,] 2 0\n## [2,] 1 3\n\n\nen bas à gauche\nen haut à gauche\nen bas à droite (n.b : le chiffre 0 indique qu’aucun plot ne pourra \\(\\tilde{\\mathrm{A}}^{\\text {a }}\\) tre affiché dans cette zone) 5.2 Utiliser la fonction layout et la matrice layMat pour créer une grille d’affichage ayant les proportions suivantes, puis afficher le résultats (indice : layout.show()) :\npremière colonne : \\(70 \\%\\) de la largeur totale\ndeuxième colonne : \\(30 \\%\\) de la largeur totale\npremière ligne : \\(30 \\%\\) de la largeur totale\ndeuxième ligne : \\(70 \\%\\) de la largeur totale 5.3 Afficher sur ce layout les 3 graphiques suivants:\nle scatter plot de la question 1\nl’histogramme de la variable “eruption”\nl’histogramme de la variable “waiting” (indice : pensez à mettre l’hitogramme à l’horizontal)\n\n#1\ndata(faithful)\n?faithful\nplot(faithful$waiting, faithful$eruptions)\nabline(v=63, col=\"red\")\n#2\nvec = rnorm(100000, mean = mean(faithful$eruptions), sd = sd(faithful$eruptions))\n#3\nhist(faithful$eruptions, freq = FALSE, main = \"Histogramme de la durée des eruptions\", xlab = \"Durée de\n#4\nlines(density(vec))\n#5\n#5.1\nlayMat = matrix(c(2,0,1,3), ncol=2, byrow=TRUE)\n#5.2\nlayout(layMat, widths=c(0.7, 0.3), heights=c(0.3, 0.7 ))\nlayout.show(n=3)\n    ## scatter plot\nplot(faithful, xlim=range(faithful$eruptions), ylim=range(faithful$waiting))\nxhist = hist(faithful$eruptions, plot=FALSE, breaks=20)\nyhist = hist(faithful$waiting , plot=FALSE, breaks=20)\nbarplot(xhist$density, axes=FALSE, space=0)\nbarplot(yhist$density, axes=FALSE, space=0, horiz=TRUE)",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercices de Niveau Avancé</span>"
    ]
  },
  {
    "objectID": "exos/togofurther.html#exercice-22-ah-si-jétais-riche",
    "href": "exos/togofurther.html#exercice-22-ah-si-jétais-riche",
    "title": "23  Exercices de Niveau Avancé",
    "section": "Exercice 22: ah si j’étais riche !",
    "text": "Exercice 22: ah si j’étais riche !\nUn ami vous propose le jeu suivant. On lance un dé. Si le résultat est 5 ou 6 , on gagne \\(3 €\\), si le résultat est 4 on gagne \\(1 €\\) et si c’est 3 ou moins on perd \\(2.5 €\\). Avant d’accepter la partie, vous essayez de simuler ce jeu, pour voir si vous avez des chances de vous enrichir.\n\nCréer une fonction simul qui prend comme argument un entier compris entre 1 et 6 , et qui retourne la somme correspondante.\nCréer un vecteur tirage, simulant le résultat de 1000 tirages de dés.\nAfficher sur un graphique la simulation du jeu.\n\nConclusion?\n#1\nsimul = function(i){\n    res = NULL\n    if (i &lt;= 6 && i &gt;= 1){\n        res = switch(i, -2.5, -2.5, -2.5, 1, 3, 3)\n    }\n    else {\n        warning(\"Un tirage de dès en peut donner qu'un chiffre entre 1 et 6\")\n    }\n    return(res)\n}\n#2\ntirage = sample(x = c(1:6),size = 1000, replace = TRUE )\n#3\nresultat = sapply(tirage, simul)\ngain = cumsum(resultat)\nplot(gain)",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercices de Niveau Avancé</span>"
    ]
  },
  {
    "objectID": "exos/togofurther.html#exercice-23-james-bond-autour-du-monde",
    "href": "exos/togofurther.html#exercice-23-james-bond-autour-du-monde",
    "title": "23  Exercices de Niveau Avancé",
    "section": "Exercice 23 : James Bond autour du monde",
    "text": "Exercice 23 : James Bond autour du monde\nR contient de nombreux packages nous permettant de faire des représentations graphiques de toutes sortes. Certains packages permettent de faire des représentations spatiales (rgdal, sp, rgeos,cartography). Connu comme une boite à outil dédiée à la cartographie thématique, le package cartography est développé au sein de l’UMS RIATE (CNRS, CGET, Université Paris Diderot) par Nicolas Lambert et Timothée Giraud.\nCommencez par installer le package cartograpgy disponible sur le CRAN (via l’utilitaire RStudio ou en ligne de commande).\nNous allons construire une carte dont l’objectif sera de montrer le nombre de fois où 007 s’est rendu dans chaque pays.\nPour cela, télécharger les données disponibles à l’adresse suivante : http://wukan.ums-riate.fr/bond/bondfiles. RData. Nous avons chargé 2 objets :\n\nLe data frame BondVisits contient 2 colonnes, l’identifiant des pays (ISO2) et le nombre de visites (n).\nLa liste WorldCountries : cette liste est une SpatialPolygonsDataFrame (spdf) contenant la carte de tous les pays du monde.\n\n\nAfficher la carte du monde grÃcce à la fonction plot, qui prend en argument des données au format spdf, avec l’arrière plan en gris. On voit que les marges de la figures sont trop grandes. Modifiez les pour maximiser l’espace pris par la map monde. Redessinez la map monde. Indice par() option mar\nAjouter les cercles proportionnels correspondant aux nombres de visites dans chaque pays de 007, avec la couleur de votre choix et des bords blanc. Modifier le titre de la légende de “n” à “Nombres de visites”.\nOn veut à présent représenter le nombres de visites par des couches de couleurs différentes plutôt que par des symboles proportionnels. Quelle fonction doit-on utiliser ? Appliquer la fonction aux données. Le résultat obtenu vous parait-il correct?\nRegarder le contenu de l’objet WorldCountries@data. Construisez un nouveau dataframe contenant tous les pays et les nombres de visites (NA ou 0 si inconnu). Réessayez de créer le graphique de la question précédente. Indice : pour créer le nouveau dataframe, la fonction merge peut vous être utile\n\nlibrary(cartography)\nload((url(\"http://wukan.ums-riate.fr/bond/bondfiles.RData\")))\nhead(BondVisits)\nplot(WorldCountries, bg=\"gray\")\npar(mar = c(0,0,1.2,0))\nplot(WorldCountries, bg=\"gray\")\npropSymbolsLayer(spdf = WorldCountries, df = BondVisits, var=\"n\", border=\"white\", col=\"magenta3\", legen\nchoroLayer(spdf = WorldCountries, df = BondVisits, var=\"n\")\nBondVisits2 = merge(BondVisits, WorldCountries@data, by=\"ISO2\", all.y=TRUE)\nchoroLayer(spdf = WorldCountries, df = BondVisits2, var=\"n\", legend.title.txt = \"Nombre de visites\")",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercices de Niveau Avancé</span>"
    ]
  },
  {
    "objectID": "exos/togofurther.html#exercice-24-profil-cgh",
    "href": "exos/togofurther.html#exercice-24-profil-cgh",
    "title": "23  Exercices de Niveau Avancé",
    "section": "Exercice 24 : Profil CGH",
    "text": "Exercice 24 : Profil CGH\nLes technologies de génomique permettent de détecter des abérrations au niveau de notre génome (CNA - Copy Number Alteration) : duplication, remaniement, translocation, perte, etc … En cancérologie, le génome des tumeurs est souvent anormal (voir la figure “Profil CGH”).\nCet exercice a pour objectif de reconstruire ce profil à partir du package “chromosomes” (développé par B. Job, Gustave Roussy) et du jeu de données A01.ASPCF, issu de l’analyse par des microarrays du type “Oncoscan” (Affymetrix) de la tumeur d’un patient.\n\nInstaller le package ‘chromosomes_1.0-0.tgz’ (ce fichier est récupérable sur le site du TP). Charger le package avec la commande library(); Enfin, charger le dataset hg19. Ceci importe dans votre session \\(R\\) une variable nommée cs (chromosome structure) décrivant les positions du génome humaine (version hg19).\n\n\nQuelle est la classe de la variable cs ?\nCombien le génome contient-il de chromosomes? (Indice : parcourir l’obet cs avec la fonction str)\nQuelle est la taille du génome humain (dans sa version hg19) ?\n\n\nCharger le fichier A01. ascat. ASPCF.RDS dans la variable cgh\n\n\nQuelle est la classe de la variable cgh ?\nCombien d’éléments contient cette variable ?\nQuelle est le genre du patient à qui correspond le profil?\n\n\nConstruction du profil CNA \n\nFigure 1: Profil CGH a. Construction des vecteurs de points à afficher depuis la variable cgh :\n\nCréer le vecteur tumor_lr à partir de la variable cgh\nCréer le vecteur x_snp contenant les positions génomique des points de mesure\nCréer le vecteur x_chr contenant les nom des chromosomes auxquels appartiennent les points de mesure\nCréer le vecteur all_chr contenant une seule occurrence de ces noms de chromosomes\n\n\nEn utilisant la variable cs, construisez le vecteur chr_length, contenant les longueurs des chromosomes. Utiliser la fonction names et la variable cs pour nommer tous les éléments du vecteur chr_length.\nConvertir les positions relatives au chromosome du vecteur \\(x_{-}\\)snp en position absolue sur le génome (vecteur x_snp_abs)\nAfin d’afficher une version lissée du signal mesuré, calculer la “running médiane” (Indice : fonction runmed) à partir du vecteur l2r_tumor\nA partir de ces vecteurs, essayez de reproduire l’image suivante.\n\nIndice: les lignes vertes correspondent à la moyenne des valeurs absolues des différences mesurées entre deux sondes\n#1\ninstall.packages(\"chromosomes_1.0-0.tar.gz\", repos = NULL, type = \"source\")\nlibrary(\"chromosomes\")\ndata(hg19)\n#1.1\nclass(cs)\n#1.2\nstr(cs)\nlength(cs$chromosomes$chrom)\n\nFigure 2: Ebauche de Profil CGH\n#1.3\nstr(cs)\ncs$genome.length\n#2\ncgh = readRDS(file = \"data/A01.ascat.ASPCF.RDS\")\n#2.1\nclass(cgh)\n#2.2\nlength(cgh)\n#2.3\ncgh$gender\n#3.1\ny_tumor_12r = cgh$Tumor_LogR[,1]\nx_snp = as.numeric(as.vector(cgh$SNPpos$pos))\nx_chr = as.vector(cgh$SNPpos$chrs)\nall_chr = unique(x_chr)\n#3.2\nchr_length = cs$chromosomes$chr.length.toadd\nchr_names = cs$chromosomes$chrN\nnames(chr_length) = chr_names\n#3.3\nx_snp_abs = x_snp\nfor (i in all_chr){\n    idx = which(x_chr == i)\n    if (i == \"X\") { tmp.chr = 23}\n    else if (i == \"Y\") { tmp.chr = 24}\n    else { tmp.chr = as.numeric(i)}\n    valtoadd = chr_length[tmp.chr]\n    x_snp_abs[idx] = x_snp_abs[idx] + valtoadd\n}\n#3.4\nl2r_runmed = runmed(y_tumor_l2r , k = 301)\n#3.5\nplot(x_snp_abs, y_tumor_l2r, ylim = c(-2, 2),col = \"gray\", pch = \".\", ylab = \"Log2R\", xlab = \"\", axes =\naxis(2)\npoints(x_snp_abs, l2r_runmed, col=\"blue\", pch = \".\")\nabline(h = 0, lty = 2, col = \"red\")\nabline(v = c(0,cs$chromosomes$chr.length.sum), lty = 2, col = \"black\")\nbox(lwd = 2)\ntmp = mean(abs(diff(y_tumor_12r)))\nabline(h = c(-tmp, tmp), lty = 2, col = \"darkgreen\")\npair = seq(from = 2, to = 24, by = 2)\nimpair = seq(from = 1, to = 23, by = 2)\ntext(x = cs$chromosomes$mid.chr[pair] + cs$chromosomes$chr.length.toadd[pair], y = 1.7 , labels = a\ntext(x = cs$chromosomes$mid.chr[impair] + cs$chromosomes$chr.length.toadd[impair], y = -1.7, labels = a",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercices de Niveau Avancé</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Documentation officielle de R\nIntroduction à R par RStudio",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "custom_RStudio.html",
    "href": "custom_RStudio.html",
    "title": "Configuration de RStudio",
    "section": "",
    "text": "Dans cette partie nous allons apprendre à personnaliser RStudio de sorte à avoir un environnement de travail agréable à utiliser.​\nLorsque que vous ouvrez RStudio pour la première fois, votre écran doit ressembler à ça.\n\n\n\nimage\n\n\nLes versions de R et RStudio peuvent être legerement différentes, donc quelques différences sont possibles entre ce que vous avez sur votre ordinateur et ce que vous pouvez observer sur cette capture d’écran.\nL’organisation de ces parties est complètement modulable à votre guise dans :\nTools &gt; Global options\nNous allons débuter par personaliser le Pane Layout.\nTools &gt; Global options &gt; Pane Layout\n\n\n\nimage\n\n\n\nEn haut à gauche vous avez la fenêtre Source, là où les scripts s’ouvriront.\nEn haut à droite la fenêtre Environnement, History, Connections, VSC, Tutorial, Presentation. Sélectionnez :\n\nEnvironnement\nHistory\nConnections\nBuild\nVCS\nTutorial : Cet onglet va vous permettre d’accéder à un ensemble de tutoriels très pratique pour apprendre à coder en R.\n\nEn bas à gauche la fenêtre Console, pour le moment avec Terminal et Background Jobs. Vide à chaque ouverture de RStudio, cette fenêtre est l’endroit où les codes vont être activés.\nEn bas à droite la fenêtre Files, Plots, Packages, Help, Viewer, Presentations. Sélectionnez :\n\nFiles\nPlots\nPackages\nHelp\nViewer\nPresentations\n\n\nNous allons à présent ajuster l’apparence de RStudio suivant nos propres préférences. Le chemin pour ces modification est toujours le même :\nTools &gt; Global options\nNous commençons par R General :\nTools &gt; Global options &gt; R General\n\n\n\nimage\n\n\n\nVérifiez si la version préente est la dernière en cliquant sous R version sur Change.\nWorkspace : Décocher Restore .RData into workspace at startup, de même choisissez Never pour Save workspace to .RData on exit.\nHistory : Laissez décochés les deux paramètres.\nOther : Laissez cochés les trois premiers paramètres.\n\nNous passons à Code/Editing :\nTools &gt; Global options &gt; Code &gt; Editing\n\n\n\nimage\n\n\nSélectionnez Use native pipe operator\nNous passons à Code/Display :\nTools &gt; Global options &gt; Code &gt; Display\n\n\n\nimage\n\n\nSélectionnez Use rainbow parentheses\nNous passons à Appearance :\nTools &gt; Global options &gt; Appearance\n\n\n\nimage\n\n\nA vous de sélectionner les options qui vous conviennent le mieux !\n\nNe pas oublier de cliquer sur apply !\n\nAfin de vérifier si vous avez la bonne version, vous pouvez rentrer dans la Console\nsessionInfo()\n\n\n\nimage",
    "crumbs": [
      "R et RStudio",
      "Configuration de RStudio"
    ]
  },
  {
    "objectID": "intro_projets.html",
    "href": "intro_projets.html",
    "title": "Les projets avec RStudio",
    "section": "",
    "text": "Un projet centralise les éléments de travail et facilite la compréhension et la réutilisation du code. Un projet, c’est une manière de travailler qui va vous permettre d’écrire du code, mais pas que. En effet, un projet RStudio est globalement un dossier informatique dans lequel se trouvent des données, des scripts mais aussi de la documentation, des images et tout ce qu’il vous faut pour travailler. Lorsqu’on travaille sous forme de projet, il n’y a pas d’interaction involontaire entre les codes de différents projets.\n\nMaintenir les packages R et Rstudio à jour.\nLes packages peuvent être mis à jour dans l’onglet Packages puis en cliquant sur Update ou dans le menu Tools &gt; Check for Package Update. À faire au moins une fois par mois.\n\nLors de la création d’un projet, le dossier ne contient que le fichier .Rproj , c’est le projet. Il est très fortement conseillé de créer des sous-dossiers : - data_raw (qui regroupent toutes les données brutes) - data (qui regroupent les données retravaillées) - doc (de la documentation ou tout autre document utile) - img (les images utiles à notre projet)\nNous allons à présent créer notre premier projet. Il y a plusieurs chemin pour créer un projet, tous sont équivalents. Une possibilité est de cliquer sur Project en haut à droite de votre fenêtre RStudio.\n\n\n\nimage\n\n\nVous avec alors la possibilité de créer un projet à partir d’un dossier vide ou existant. Nous choisirons pour cette prmière fois de créer un projet à partir d’un dossier vide. Nous créons quatre sous dossiers : data_raw, data, doc et img.\n\n\n\nimage\n\n\nOn peut alors observer dans le cadran en bas à droite : - 1st_project.Rproj - data - data_raw - doc - img",
    "crumbs": [
      "Les projets avec RStudio"
    ]
  },
  {
    "objectID": "R_RStudio.html",
    "href": "R_RStudio.html",
    "title": "R et RStudio",
    "section": "",
    "text": "Il est nécessaire d’avoir :\n\nsoit un pc windows\nsoit un ordinateur avec une distribution linux, par exemple Ubuntu\nsoit un mac\n\nIl est aujourd’hui possible de trouver des ordinateurs de qualité à moindre prix, en reconditionné, par exemple sur ce site https://www.backmarket.fr/fr-fr.",
    "crumbs": [
      "R et RStudio"
    ]
  },
  {
    "objectID": "intro_script.html",
    "href": "intro_script.html",
    "title": "Ecrire des scripts sur RStudio",
    "section": "",
    "text": "coming.",
    "crumbs": [
      "Ecrire des scripts sur RStudio"
    ]
  },
  {
    "objectID": "intro_scriptQuarto.html",
    "href": "intro_scriptQuarto.html",
    "title": "Script Quarto",
    "section": "",
    "text": "Quarto, c’est la nouvelle génération de R markdown. De manière basique, vous pourrez générer des documents (qui intègrent ou pas du code R) dans les formats html, word ou pdf, mais avec plus de facilité pour gérer, par exemple, les images, les références croisées. Vous pourrez également réaliser des diapositives, des dashboards et des sites webs, des livres, comme R markdown mais nativement, c’est à dire sans faire appel à des packages complémentaires comme bookdown (livres), xaringan (slides), flexdasboard (dashboard).\nVoici un rapide tour d’horizon de la syntaxe, pour plus d’informations :\n\nLe saut de ligne est marqué par un double espace (en fin d’une ligne).\nLes étoiles servent à marquer :\n\nEn italique : *italique*\nEn gras : **gras**\nEn gras et italique : ***gras et italique***\nPour raturer on utiliser les tildes : ~~raturé~~\n\nPour la syntaxe code les impostropes : `code`\nLes titres sont précédés de#, autant que de niveaux :\n\nTitre de premier niveau : # Titre de premier niveau\nTitre de deuxième niveau : ## Titre de deuxième niveau\nTitre de troisième niveau : ### Titre de troisième niveau\n\n\nVous pouvez retrouver les principales syntaxes sur Markdown à cette page.\nNous allons créer notre premier script Quarto.\n\nCréer un nouveau document Quarto File &gt; New File &gt; Quarto Document\nPour cette premire fois choisissez les options suivantes :\n\n\n\n\nimage\n\n\n\nVous allez probablement avoir besoin d’installer le package Rmarkdown. Pour cela il vous suffit d’aller dans le cadran en bas à droite et de cliquer sur Packages puis Install. Une boite de dialogue s’ouvre :\n\n\n\n\nimage\n\n\nCliquez sur Install, et enregistrez votre script. Le script Quarto apparrait alors dans le cadran en bas à droite dans la fenetre Files. Vous pouvez vous amuser avec ce script, lancer les morceaux de code R. Pour générer le document html cliquer sur la petite fleche bleue Render the current document, ou utilser le raccourci Ctrl + Shift + K.\nSi vous souhaitez modifier la le format de sortie, par exemple récupérer un pdf à la place d’un html, il vous suffit d’crire pdf à la place de html dans le code : fenetre en haut à gauche puis Source.\nUn ensemble d’exemple de ce qui est possible de faire avec Quarto.",
    "crumbs": [
      "Ecrire des scripts sur RStudio",
      "Script Quarto"
    ]
  },
  {
    "objectID": "intro_scriptR.html",
    "href": "intro_scriptR.html",
    "title": "Script R",
    "section": "",
    "text": "Nous allons créer notre premier script R.\n\nCréer un nouveau document Quarto File &gt; New File &gt; R Script\nEnregistrer votre script\nEcrivez votre première ligne de code sur R :\n\n2 + 3\n\nEnregistrez votre script\nCliquer sur Run, en haut à droite du cadran en haut à gauche.\n\n\nDans la partie suivante nous allons voir les bases du language R.",
    "crumbs": [
      "Ecrire des scripts sur RStudio",
      "Script R"
    ]
  },
  {
    "objectID": "bases_R.html",
    "href": "bases_R.html",
    "title": "Bases du langage R",
    "section": "",
    "text": "Nous allons travailler dans notre script R.",
    "crumbs": [
      "Bases du langage R"
    ]
  },
  {
    "objectID": "help.html",
    "href": "help.html",
    "title": "Obtenir de l’aide sur R",
    "section": "",
    "text": "Le système d’aide en ligne fourni avec R est accessible via la commande help(). Lorsque l’on connaît le nom de la commande R, par exemple, cmd, on peut taper help(cmd) ou ?cmd (sauf dans le cas de certains opérateurs). Sinon, on peut rechercher à partir de mots-clés en tapant help. search(). Une alternative pour la recherche par motif consiste à utiliser apropos(). Pour connaître toutes les commandes fournies par un package (e.g., pkg), il suffit de taper help(package=pkg).",
    "crumbs": [
      "Bases du langage R",
      "Obtenir de l’aide sur R"
    ]
  },
  {
    "objectID": "startR.html",
    "href": "startR.html",
    "title": "Quelques premières notions",
    "section": "",
    "text": "Nous avons vu que R peut effectuer des opérations mathématiques. Par exemple :\n2 + 3\nou encore\n2 * 3\nPour récupérer du texte en sortie, il est nécesaire de l’écrire de cette façon :\n\"ISTOM, Ecole supérieure d'agro-développement international\"\nSans les guillemets R retourne une erreur.\nEn revanche pour récupérer des nombres en sortie, il suffit simplement de rentrer ces nombres :\n105\n8\n89\n2576\n978364\nAfin d’ajouter des commentaires dans votre code (tres fortement conseillé), il suffit d’écrire :\n# L'école la plus cool ;-)\n\"ISTOM, Ecole supérieure d'agro-développement international\"\nIl est très souvent utile de créer des variables. Cela se fait de la manière suivante\necole &lt;- \"ISTOM\"\nadresse &lt;- \"4 Rue Joseph Lakanal, 49000 Angers\"\ndate_creation &lt;- 1908\nDe cette façon si ensuite vous rentrez\necole\nil vous sortira simplement ISTOM.\nOn peut également manipuler ces variables. Par exemple :\npaste(\"L'\",ecole,\"a été créée en\",date_creation) \nou encore\ndate_creation &lt;- 1908\nnombre_etudiant_promotion &lt;- 60\n\n(2025-date_creation)*nombre_etudiant_promotion\nOn peut attribuer la même valeur à plusieurs variables.\nvar1 &lt;- \"Angers\"\nvar2 &lt;- \"Angers\"\nvar3 &lt;- \"Angers\"\n\nvar1\nvar2\nvar3",
    "crumbs": [
      "Bases du langage R",
      "Quelques premières notions"
    ]
  },
  {
    "objectID": "types_data.html",
    "href": "types_data.html",
    "title": "Les différents types de données",
    "section": "",
    "text": "Il existe différents types de données sur R, on peut citer :\n\nnumeric (10.5, 55, 787)\ninteger (1L, 55L, 100L, où le “L” informe R que c’est un integer)\ncomplex (9 + 3i)\ncharacter / string (“k”, “Les stat c’est cool”, “FALSE”, “11.5”)\nlogical / boolean - (TRUE or FALSE)\n\nOn peut vérifier le type de donnée d’une variable en utilisant la fonction class().\n# numeric\nx &lt;- 10.5\nclass(x)\n\n# integer\nx &lt;- 1000L\nclass(x)\n\n# complex\nx &lt;- 9i + 3\nclass(x)\n\n# character/string\nx &lt;- \"R is exciting\"\nclass(x)\n\n# logical/boolean\nx &lt;- TRUE\nclass(x) \nIl y a trois types de nombres : numeric, integer et complex. On peut convertir un nombre d’un type à un autre en utilsant les fonctions :\n\nas.numeric()\nas.integer()\nas.complex()\n\nPlusieurs fonctions utiles pour les character / string :\n\nConnaitre la longueur d’une string : nchar(ecole)\nSavoir si une string est contenue dans une autre string : grepl(\"I\",ecole)\nRegrouper deux strings : paste(\"Cette ecole a été créée en\",date_creation)\n\nEn ce qui concerne les vraiables logical / boolean on a simplement :\n10 &gt; 9    # TRUE car 10 est plus grand que 9 !\n10 == 9   # FALSE car 10 n'est pas egale à 9 !\n10 &lt; 9    # FALSE car 10 est plus grand que 9 ! \nQuelques outils d’arithmétques :\n2 + 3 # Addition    \n2 - 3 # Subtraction     \n2 * 3 # Multiplication  \n2 / 3 # Division\n2^3 # Exponent\nQuelques outils de comparaison\n3 == 3 # Check if equal     \n5 != 3 # Check if not equal \n5 &gt; 3 # Check if 5 is greater than 3    \n5 &lt; 3 # Check if 5 is less than 3 \n5 &gt;= 3 # Check if 5 is greater than or equal to 3\n5 &lt;= 3 # Check if 5 is less than or equal to 3\nOn peut ranger ces données dans différents objets :\n\nVecteurs : Une séquence d’éléments du même type.\n\nx &lt;- c(55, 1, 2, 3, 4)\nx\nlength(x)\nsort(x)\nx[3]\nx[c(1,3)]\nx[c(-1)]\nx[4] &lt;- 100 \nx\n-Listes : Une séquence d’éléments qui peuvent être différents.\nma_liste &lt;- list(\"apple\", \"banana\", \"cherry\")\nma_liste\nma_liste[1]\nma_liste[2] &lt;- \"pineapple\"\nlength(ma_liste)\n\"apple\" %in% ma_liste \nappend(ma_liste,\"orange\",after=3)\n\nMatrices : Tableau à deux dimensions.\n\nmat &lt;- matrix(1:9, nrow = 3, ncol = 3)\nmat\nmat[1,2]\nmat[1,]\nmat[,2]\nmat[c(1,2),] \nmat[,c(1,2)] \nmat_add_column &lt;- cbind(mat,c(50,8,47))\nmat_add_column\nmat_add_row &lt;- rbind(mat,c(50,8,47))\nmat_add_row\nmat_remove_line_column_one &lt;- mat[-c(1), -c(1)]  #Remove the first row and the first column\nmat_remove_line_column_one\ndim(mat)\n\nData frames : Tableau avec colonnes pouvant contenir différents types de données.\n\ndf &lt;- data.frame(\n    Age = c(25, 30, 35), \n    Sexe = c('Homme', 'Femme', 'Homme'))\ndf\nsummary(df)\ndf[1]\ndf[[\"Age\"]]\n\nFacteurs : c’est un vecteur dont les éléments ne peuvent prendre que des modalités prédéfinies. Ce qui caractérise un facteur dans R est le fait qu’elle dispose de l’attribut Levels (niveaux). En pratique, un facteur est typiquement utilisé pour stocker les valeurs observées d’une variable catégorielle (couleur, sexe, jours de la semaine, religion, …).\n\nmusic_genre &lt;- factor(c(\"Jazz\", \"Rock\", \"Classic\", \"Classic\", \"Pop\", \"Jazz\", \"Rock\", \"Jazz\"))\nmusic_genre\nlevels(music_genre) \nlength(music_genre) \nmusic_genre[3] \nmusic_genre[3] &lt;- \"Pop\"\nmusic_genre",
    "crumbs": [
      "Bases du langage R",
      "Les différents types de données"
    ]
  },
  {
    "objectID": "Loops.html",
    "href": "Loops.html",
    "title": "Conditions, boucles",
    "section": "",
    "text": "If … Else\nLe mieux est d’illustrer ceci sur un exemple :\na &lt;- 200\nb &lt;- 33\n\nif (b &gt; a) {\n  print(\"b is greater than a\")\n} else if (a == b) {\n  print(\"a and b are equal\")\n} else {\n  print(\"a is greater than b\")\n}  \n\n\nNested If\nSur un exemple :\nx &lt;- 41\n\nif (x &gt; 10) {\n  print(\"Above ten\")\n  if (x &gt; 20) {\n    print(\"and also above 20!\")\n  } else {\n    print(\"but not above 20.\")\n  }\n} else {\n  print(\"below 10.\")\n} \n\n\nAND, OR\nUn exemple pour AND\na &lt;- 200\nb &lt;- 33\nc &lt;- 500\n\nif (a &gt; b & c &gt; a) {\n  print(\"Both conditions are true\")\n} \nUn exemple pour OR\na &lt;- 200\nb &lt;- 33\nc &lt;- 500\n\nif (a &gt; b | a &gt; c) {\n  print(\"At least one of the conditions is true\")\n}\n\n\nLoops\nR a deux commandes pour les boucles : - while loops - for loops\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n}\nun autre exemple\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n  if (i == 4) {\n    break\n  }\n} \nUn dernier exemple pour illsutrer la fonction next\ni &lt;- 0\nwhile (i &lt; 6) {\n  i &lt;- i + 1\n  if (i == 3) {\n    next\n  }\n  print(i)\n} \nUn exemple pour une boucle for\nfruits &lt;- list(\"apple\", \"banana\", \"cherry\")\n\nfor (x in fruits) {\n  print(x)\n} \nou encore\nadj &lt;- list(\"red\", \"big\", \"tasty\")\nfruits &lt;- list(\"apple\", \"banana\", \"cherry\")\n  for (x in adj) {\n    for (y in fruits) {\n      print(paste(x, y))\n  }\n}",
    "crumbs": [
      "Bases du langage R",
      "Conditions, boucles"
    ]
  },
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Les fonctions",
    "section": "",
    "text": "Pour créer une fonction on écrit :\n my_function &lt;- function() { # create a function with the name my_function\n  print(\"L'ISTOM c'est top!\")\n} \n\nmy_function()\nOn peut créer des fonctions avec des arguments :\nma_promo &lt;- function(promo,groupe) {\n  paste(\"Promotion\", promo, \"groupe\", groupe)\n}\n\nma_promo(114,\"A\")\nma_promo(115,\"B\") \nOn a également :\nma_multiplication &lt;- function(x) {\n  return (5 * x)\n}\n\nprint(ma_multiplication(3))\nprint(ma_multiplication(5))\nprint(ma_multiplication(9))",
    "crumbs": [
      "Bases du langage R",
      "Les fonctions"
    ]
  },
  {
    "objectID": "graph.html",
    "href": "graph.html",
    "title": "Les graphiques",
    "section": "",
    "text": "Le mieux est d’encore de travailler sur des exemples. Pour tracer le point de coordonnées (1,3) on écrit :\nplot(1, 3) \npour tracer les points de coordonnées (1,3) et (8,10) on écrit :\n plot(c(1, 8), c(3, 10)) \nde la même façon on a :\nx &lt;- c(1, 2, 3, 4, 5)\ny &lt;- c(3, 7, 8, 9, 12)\n\nplot(x, y)\npour tracer les points (1,1), (2,2), (3,3), …, (10,10) on peut écrire\nplot(1:10) \nsi on veut tracer une ligne qui passe par ces points on écrit\nplot(1:10, type=\"l\",lwd=2, lty=3) \nL’argument lwd permet de modifier l’epaisseur de la ligne tracée, sachant que 0.5 correspond à 50% et 2 à 100%. L’arguement lty permet de modifier le style de la ligne : - 0 removes the line - 1 displays a solid line - 2 displays a dashed line - 3 displays a dotted line - 4 displays a “dot dashed” line - 5 displays a “long dashed” line - 6 displays a “two dashed” line\nOn peut affiner la présentation de notre graphique :\nplot(1:10, main=\"My Graph\", xlab=\"The x-axis\", ylab=\"The y axis\",col=\"green\",cex=0.5,pch=11) \nL’argument cex permet de réduire ou augementer a taille des points, sachant que 0.5 correspond à 50% et 2 à 100%. L’argument pch permet de changer le style des points tracés, de 0 à 25 : \nUn autre exemple\nline1 &lt;- c(1,2,3,4,5,10)\nline2 &lt;- c(2,5,7,8,9,10)\n\nplot(line1, type = \"l\", col = \"blue\")\nlines(line2, type=\"l\", col = \"red\") \nPour comparer des données sur un graphe :\nx1 &lt;- c(5,7,8,7,2,2,9,4,11,12,9,6)\ny1 &lt;- c(99,86,87,88,111,103,87,94,78,77,85,86)\n\nx2 &lt;- c(2,2,8,1,15,8,12,9,7,3,11,4,7,14,12)\ny2 &lt;- c(100,105,84,105,90,99,90,95,94,100,79,112,91,80,85)\n\nplot(x1, y1, main=\"mon titre\", xlab=\"l'axe x\", ylab=\"l'axe y\", col=\"red\", cex=2)\npoints(x2, y2, col=\"blue\", cex=2)\nPie Charts - Diagramme circulaire\nx &lt;- c(10,20,30,40)\nmylabel &lt;- c(\"Apples\", \"Bananas\", \"Cherries\", \"Dates\")\ncolors &lt;- c(\"blue\", \"yellow\", \"green\", \"black\")\npie(x,, label = mylabel, main = \"Fruits\",col = colors,init.angle = 90) \nlegend(\"bottomright\", mylabel, fill = colors) \nBar Charts\nx &lt;- c(\"A\", \"B\", \"C\", \"D\")\ny &lt;- c(2, 4, 6, 8)\nbarplot(y, names.arg = x, col = \"red\",density = 10,width = c(1,2,3,4))\nbarplot(y, names.arg = x, horiz = TRUE)",
    "crumbs": [
      "Bases du langage R",
      "Les graphiques"
    ]
  },
  {
    "objectID": "analysis_dataset.html",
    "href": "analysis_dataset.html",
    "title": "Inroduction à l’analyse de données",
    "section": "",
    "text": "Importer des données dans RStudio\nRStudio est l’environnement qui va vous permettre d’analyser vos données. Vous allez maintenant apprendre à charger des données dans RStudio, les modifier puis les ressortir de RStudio.\nNous allons apprendre à ouvrir un fichier CSV consacré que voustéléchargerez sur le site open data du gouvernement. Choisissez un jeu de donnée qui vous interesse. Vous enregistrer ce fichier dans le dossier data_raw de votre projet sous R. Ce fichier CSV est un fichier texte où les données sous formes de tables sont séparées par des virgules. C’est le format de table par excellence à privilégier car nativement pris en compte par R, sans limite de lignes, contrairement à Excel. Pour ma part j’ai choisi ce jeu de données.\nEcrivez sous R\nVous récupérez dans le cadran en bas à droite la documentation de la fonction read.csv.\nIl est nécessaire de charger le package readxl. Deux possibilités s’offrent à nous, soit on procède comme précement pour le package rmarkdown, soit on écrit sur la ligne de code suivante :\nEt maintenant nous allons charger les données d’un fichier excel récupérer sur ce site.\nCela ne fonctionne malheuresement pas très bien. Il est nécessaire de péciser l’onglet sur lequel on va travailler et les celules qui nous intéressent.\nEnfin pour ajouter les titre de chacune des colonnes on écrit",
    "crumbs": [
      "Inroduction à l'analyse de données"
    ]
  },
  {
    "objectID": "import_dataset.html",
    "href": "import_dataset.html",
    "title": "Importer des données dans RStudio",
    "section": "",
    "text": "RStudio est l’environnement qui va vous permettre d’analyser vos données. Vous allez maintenant apprendre à charger des données dans RStudio, les modifier puis les ressortir de RStudio.\nNous allons apprendre à ouvrir un fichier CSV consacré que voustéléchargerez sur le site open data du gouvernement. Choisissez un jeu de donnée qui vous interesse. Vous enregistrer ce fichier dans le dossier data_raw de votre projet sous R. Ce fichier CSV est un fichier texte où les données sous formes de tables sont séparées par des virgules. C’est le format de table par excellence à privilégier car nativement pris en compte par R, sans limite de lignes, contrairement à Excel. Pour ma part j’ai choisi ce jeu de données.\n\nTélécharger le jeu de données au format CSV\nEnregistrer ce fichier CSV dans le dossier data_raw de votre projet sous R\nSous R, rentrer le code :\n\n\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\n\nVous récupérer dans le cadran en haut à droite, dans Environment, l’ensemble des varaibles de votre fichier CSV\n\n\nPour éviter les erreurs : Lisez la page d’aide avant d’utiliser une fonction pour la première fois grâce à la fonction help() ou l’onglet Help.\n\nEcrivez sous R\n&gt; help(\"read.csv\")\nVous récupérez dans le cadran en bas à droite la documentation de la fonction read.csv.\n\nIl est cependant fréquent que les données ne soit pas regroupées dans un fichier CSV, mais directement dans un fichier Excel.\n\nIl est nécessaire de charger le package readxl. Deux possibilités s’offrent à nous, soit on procède comme précement pour le package rmarkdown, soit on écrit sur la ligne de code suivante :\ninstall.packages(\"readxl\")\nEt maintenant nous allons charger les données d’un fichier excel récupérer sur ce site.\nlibrary(readxl)\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_Occ_Ind_List.xlsx\")\nCela ne fonctionne malheuresement pas très bien. Il est nécessaire de péciser l’onglet sur lequel on va travailler et les celules qui nous intéressent.\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.4.2\n\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_table4.xlsx\", sheet = \"T4\", range = \"B10:J352\")\n\nNew names:\n• `` -&gt; `...3`\n• `` -&gt; `...4`\n• `` -&gt; `...5`\n• `` -&gt; `...6`\n• `` -&gt; `...7`\n• `` -&gt; `...8`\n• `` -&gt; `...9`\n\n\nEnfin pour ajouter les titre de chacune des colonnes on écrit\n\nlibrary(readxl)\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_table4.xlsx\", sheet = \"T4\", range = \"B10:J352\", col_names = {\n  c(\"SSOC 2020\",\"Occupation\",\"Number Covered\",\"Basic Wage - 25th Percentile ($)\", \"Basic Wage - Median  ($)\",\"Basic Wage - 75th Percentile ($)\",\"Gross Wage - 25th Percentile ($)\", \"Gross Wage - Median  ($)\",\"Gross Wage - 75th Percentile ($)\")})",
    "crumbs": [
      "Inroduction à l'analyse de données",
      "Importer des données dans RStudio"
    ]
  },
  {
    "objectID": "analysis_dataset.html#importer-des-données-dans-rstudio",
    "href": "analysis_dataset.html#importer-des-données-dans-rstudio",
    "title": "Inroduction à l’analyse de données",
    "section": "",
    "text": "Télécharger le jeu de données au format CSV\nEnregistrer ce fichier CSV dans le dossier data_raw de votre projet sous R\nSous R, rentrer le code :\n\n\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\n\nVous récupérer dans le cadran en haut à droite, dans Environment, l’ensemble des varaibles de votre fichier CSV\n\n\nPour éviter les erreurs : Lisez la page d’aide avant d’utiliser une fonction pour la première fois grâce à la fonction help() ou l’onglet Help.\n\n\n&gt; help(\"read.csv\")\n\n\nIl est cependant fréquent que les données ne soit pas regroupées dans un fichier CSV, mais directement dans un fichier Excel.\n\n\ninstall.packages(\"readxl\")\n\nlibrary(readxl)\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_Occ_Ind_List.xlsx\")\n\nlibrary(readxl)\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_table4.xlsx\", sheet = \"T4\", range = \"B10:J352\")\n\nlibrary(readxl)\nsalaire &lt;- read_excel(\"data_raw/mrsd_2022Wages_table4.xlsx\", sheet = \"T4\", range = \"B10:J352\", col_names = {\n  c(\"SSOC 2020\",\"Occupation\",\"Number Covered\",\"Basic Wage - 25th Percentile ($)\", \"Basic Wage - Median  ($)\",\"Basic Wage - 75th Percentile ($)\",\"Gross Wage - 25th Percentile ($)\", \"Gross Wage - Median  ($)\",\"Gross Wage - 75th Percentile ($)\")})",
    "crumbs": [
      "Inroduction à l'analyse de données"
    ]
  },
  {
    "objectID": "analysis_dataset.html#modifier-et-exporter-des-données-importées-dans-rstudio",
    "href": "analysis_dataset.html#modifier-et-exporter-des-données-importées-dans-rstudio",
    "title": "Inroduction à l’analyse de données",
    "section": "Modifier et exporter des données importées dans RStudio",
    "text": "Modifier et exporter des données importées dans RStudio\n\nReprenez les données que vous avez importé au paragraphe précédent.\nOuvrez le tableau de données en cliquant dessus dans l’onglet Environment ou en utilisant le code :\n\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\nView(mixite_groupe_edf)\nAfin de remplacer une valeur dans une cellule, il faut localiser cette cellule et lui donner sa valeur. Cela se fait de la manière suivante :\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\nmixite_groupe_edf[38, 5] &lt;- \"Mars\" # cellule à la 28eme ligne et 1ere colonne\nDe la même manière, vous allez pouvoir sélectionner toutes les lignes de plusieurs colonnes en ne mettant rien avant la virgule, et les colonnes d’intérêt listées après.\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\n\n# avec le nom des colonnes\nmixite_groupe_edf_fr &lt;- mixite_groupe_edf[, c(\"tri\", \"annee\", \"perimetre_juridique\", \"perimetre_spatial\", \"indicateur\", \"valeur_de_l_indicateur\", \"unite\", \"methode_de_consolidation\")]\n\n# ou la position des colonnes\nmixite_groupe_edf_fr &lt;- mixite_groupe_edf[, c(1:3, 5, 7, 9, 10, 12)]\nVous remarquerez qu’un nouveau tableau a été créé, associé au nom mixite_groupe_edf_fr. Il est possible de réutiliser le même nom, ce qui permet de gagner en mémoire mais élimine les données de base.\nLes modifications réalisées dans l’environnement de RStudio n’impactent pas les données en dehors tant qu’elles ne sont pas enregistrées.\nPour enregistrer une table sous format CSV, il suffit d’utiliser la fonction write.csv() :\nmixite_groupe_edf &lt;- read.csv(\"data_raw/mixite-dans-le-groupe-edf.csv\",sep = \";\")\nmixite_groupe_edf_fr &lt;- mixite_groupe_edf[, c(1:3, 5, 7, 9, 10, 12)]\nwrite.csv(x = mixite_groupe_edf_fr, file = \"data/presence_femme_edf.csv\")  . \nSi vous souhaitez enregistrer votre fichier au format XLSX (Excel), il sufiit d’écrire : ```{r} install.packages(“writexl”) library(writexl) write_xlsx(x = mixite_groupe_edf_fr, path = “data/presence_femme_edf.xlsx”)",
    "crumbs": [
      "Inroduction à l'analyse de données"
    ]
  }
]